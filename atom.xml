<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vincent&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreambo8563.github.io/"/>
  <updated>2023-04-21T07:09:46.053Z</updated>
  <id>https://dreambo8563.github.io/</id>
  
  <author>
    <name>Vincent Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>GPT结合业务探索之多步推理</title>
    <link href="https://dreambo8563.github.io/2023/04/21/GPT%E7%BB%93%E5%90%88%E4%B8%9A%E5%8A%A1%E6%8E%A2%E7%B4%A2%E4%B9%8B%E5%A4%9A%E6%AD%A5%E6%8E%A8%E7%90%86/"/>
    <id>https://dreambo8563.github.io/2023/04/21/GPT结合业务探索之多步推理/</id>
    <published>2023-04-21T06:16:45.000Z</published>
    <updated>2023-04-21T07:09:46.053Z</updated>
    
    <content type="html"><![CDATA[<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>先是看到了这个文章: <a href="https://mp.weixin.qq.com/s/noM8Hy1atF8asuj1Bagpdg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/noM8Hy1atF8asuj1Bagpdg</a><br>AutoGPT 等自动推理,自动执行的项目火热出现<br>之前看过飞书的 AI 的介绍视频,里面有创建日程的场景</p><h4 id="结合我们的场景"><a href="#结合我们的场景" class="headerlink" title="结合我们的场景"></a>结合我们的场景</h4><p>类型场景我们也有, 定会议室, 创建日程</p><h4 id="代码实践"><a href="#代码实践" class="headerlink" title="代码实践"></a>代码实践</h4><p>核心是应用 langchain 中的 Agent, Tools, Chain 来完成整个步骤<br>大致关系如下:</p><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/langchain_agent.png" alt=""></p><h3 id="Agent"><a href="#Agent" class="headerlink" title="Agent"></a>Agent</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> Tool, AgentExecutor, LLMSingleActionAgent, AgentOutputParser</span><br><span class="line"><span class="keyword">from</span> langchain.prompts <span class="keyword">import</span> StringPromptTemplate</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> OpenAI, LLMChain</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Union</span><br><span class="line"><span class="keyword">from</span> langchain.schema <span class="keyword">import</span> AgentAction, AgentFinish</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> langchain.agents <span class="keyword">import</span> tool</span><br><span class="line"><span class="keyword">from</span> dateTool <span class="keyword">import</span> dateCalculator</span><br><span class="line"><span class="keyword">from</span> dbSearch <span class="keyword">import</span> employeeSearch</span><br><span class="line"><span class="keyword">from</span> schedule <span class="keyword">import</span> getAvailabelSchedule</span><br><span class="line"><span class="keyword">from</span> session <span class="keyword">import</span> getPgMemory</span><br><span class="line"><span class="keyword">from</span> langchain.callbacks <span class="keyword">import</span> get_openai_callback</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line"><span class="comment"># 引入环境变量</span></span><br><span class="line">load_dotenv()</span><br><span class="line">llm = OpenAI(temperature=<span class="number">0</span>, verbose=<span class="literal">False</span>) <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据 uuid 创建一个临时存储, session 模块</span></span><br><span class="line">history = getPgMemory(<span class="string">"xx"</span>)</span><br><span class="line">history.clear()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 错误情况走的 Tool</span></span><br><span class="line"><span class="meta">@tool</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">error_log</span><span class="params">(s)</span> -&gt; str:</span></span><br><span class="line">    <span class="string">"""just output anything received"""</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组装 Tool, 一个用来推断会议日期, 一个是获取参会人信息, 一个是汇总信息</span></span><br><span class="line">tools = [</span><br><span class="line">    Tool(</span><br><span class="line">name = <span class="string">"Date Calculator"</span>,</span><br><span class="line">func = <span class="keyword">lambda</span> string: dateCalculator(string,history),</span><br><span class="line">description=<span class="string">"用于日期相关计算"</span></span><br><span class="line">),</span><br><span class="line">    Tool(</span><br><span class="line">        name = <span class="string">"Search"</span>,</span><br><span class="line">        func=<span class="keyword">lambda</span> string: employeeSearch(string,history),</span><br><span class="line">        <span class="comment"># description="用于查询员工信息"</span></span><br><span class="line">        description=<span class="string">"用于查询模板,模块和模块配置信息"</span></span><br><span class="line">    ),</span><br><span class="line">     Tool(</span><br><span class="line">        name = <span class="string">"Schedule"</span>,</span><br><span class="line">        func=<span class="keyword">lambda</span> string: getAvailabelSchedule(history),</span><br><span class="line">        description=<span class="string">"useful to get Availabel Schedule, 需要先Date Calculator计算出预约的时间, 在用Search分析出参会人的工号和姓名后才能调用"</span>,</span><br><span class="line">        return_direct=<span class="literal">True</span></span><br><span class="line">    ),</span><br><span class="line">      Tool(</span><br><span class="line">        name = <span class="string">"Error"</span>,</span><br><span class="line">        func= error_log,</span><br><span class="line">        description=<span class="string">"当遇到错误,需要终止程序时调用"</span>,</span><br><span class="line">        return_direct=<span class="literal">True</span></span><br><span class="line">    )</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Agent 逐步推断用的模板, 根据每一步要做的事情,选择合适的 Tool</span></span><br><span class="line">template = <span class="string">"""Answer the following questions as best you can, but speaking as a pirate might speak. You have access to the following tools:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;tools&#125;</span></span><br><span class="line"><span class="string">Use the following format(response in Chinese):</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: the input question you must answer</span></span><br><span class="line"><span class="string">Thought: you should always think about what to do</span></span><br><span class="line"><span class="string">Action: the action to take, should be one of [&#123;tool_names&#125;].</span></span><br><span class="line"><span class="string">Action Input: the input to the action</span></span><br><span class="line"><span class="string">Observation: the result of the action</span></span><br><span class="line"><span class="string"><span class="meta">... </span>(this Thought/Action/Action Input/Observation can repeat N times)</span></span><br><span class="line"><span class="string">Thought: I now know the final answer</span></span><br><span class="line"><span class="string">Final Answer: the final answer to the original input question</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Begin! Remember to speak as a pirate when giving your final answer. Use lots of "Arg"s</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: &#123;input&#125;</span></span><br><span class="line"><span class="string">&#123;agent_scratchpad&#125;"""</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的提示模板.会有Thought/Action/Observation 几个部分</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomPromptTemplate</span><span class="params">(StringPromptTemplate)</span>:</span></span><br><span class="line">    <span class="comment"># The template to use</span></span><br><span class="line">    template: str</span><br><span class="line">    <span class="comment"># The list of tools available</span></span><br><span class="line">    tools: List[Tool]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">format</span><span class="params">(self, **kwargs)</span> -&gt; str:</span></span><br><span class="line">        <span class="comment"># Get the intermediate steps (AgentAction, Observation tuples)</span></span><br><span class="line">        <span class="comment"># Format them in a particular way</span></span><br><span class="line">        intermediate_steps = kwargs.pop(<span class="string">"intermediate_steps"</span>)</span><br><span class="line">        thoughts = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> action, observation <span class="keyword">in</span> intermediate_steps:</span><br><span class="line">            thoughts += action.log</span><br><span class="line">            thoughts += <span class="string">f"\nObservation: <span class="subst">&#123;observation&#125;</span>\nThought: "</span></span><br><span class="line">        <span class="comment"># Set the agent_scratchpad variable to that value</span></span><br><span class="line">        kwargs[<span class="string">"agent_scratchpad"</span>] = thoughts</span><br><span class="line">        <span class="comment"># Create a tools variable from the list of tools provided</span></span><br><span class="line">        kwargs[<span class="string">"tools"</span>] = <span class="string">"\n"</span>.join([<span class="string">f"<span class="subst">&#123;tool.name&#125;</span>: <span class="subst">&#123;tool.description&#125;</span>"</span> <span class="keyword">for</span> tool <span class="keyword">in</span> self.tools])</span><br><span class="line">        <span class="comment"># Create a list of tool names for the tools provided</span></span><br><span class="line">        kwargs[<span class="string">"tool_names"</span>] = <span class="string">", "</span>.join([tool.name <span class="keyword">for</span> tool <span class="keyword">in</span> self.tools])</span><br><span class="line">        <span class="keyword">return</span> self.template.format(**kwargs)</span><br><span class="line"></span><br><span class="line">prompt = CustomPromptTemplate(</span><br><span class="line">    template=template,</span><br><span class="line">    tools=tools,</span><br><span class="line">    <span class="comment"># This omits the `agent_scratchpad`, `tools`, and `tool_names` variables because those are generated dynamically</span></span><br><span class="line">    <span class="comment"># This includes the `intermediate_steps` variable because that is needed</span></span><br><span class="line">    input_variables=[<span class="string">"input"</span>, <span class="string">"intermediate_steps"</span>]</span><br><span class="line">)</span><br><span class="line"><span class="comment"># LLM chain consisting of the LLM and a prompt</span></span><br><span class="line">llm_chain = LLMChain(llm=llm, prompt=prompt,verbose=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对输出做一些控制, 截取 gpt 返回的内容,并切割</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomOutputParser</span><span class="params">(AgentOutputParser)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">parse</span><span class="params">(self, llm_output: str)</span> -&gt; Union[AgentAction, AgentFinish]:</span></span><br><span class="line">        <span class="comment"># Check if agent should finishs</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> llm_output.strip(<span class="string">"\n"</span>).strip(<span class="string">" "</span>).startswith(<span class="string">"Thought:"</span>):</span><br><span class="line">            llm_output =<span class="string">"\nThought:"</span>+llm_output</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="string">"Final Answer:"</span> <span class="keyword">in</span> llm_output:</span><br><span class="line">            <span class="keyword">return</span> AgentFinish(</span><br><span class="line">                <span class="comment"># Return values is generally always a dictionary with a single `output` key</span></span><br><span class="line">                <span class="comment"># It is not recommended to try anything else at the moment :)</span></span><br><span class="line">                return_values=&#123;<span class="string">"output"</span>: llm_output.split(<span class="string">"Final Answer:"</span>)[<span class="number">-1</span>].strip()&#125;,</span><br><span class="line">                log=llm_output,</span><br><span class="line">            )</span><br><span class="line">        <span class="comment"># Parse out the action and action input</span></span><br><span class="line">        regex = <span class="string">r"Thought\s*\d*\s*:(.*?)\nAction\s*\d*\s*:(.*?)\nAction\s*\d*\s*Input\s*\d*\s*:[\s]*(.*)"</span></span><br><span class="line">        match = re.search(regex, llm_output, re.DOTALL)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> match:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">f"Could not parse LLM output: `<span class="subst">&#123;llm_output&#125;</span>`"</span>)</span><br><span class="line">        thought = match.group(<span class="number">1</span>).strip()</span><br><span class="line">        history.add_user_message(thought)</span><br><span class="line">        action = match.group(<span class="number">2</span>).strip()</span><br><span class="line">        action_input = match.group(<span class="number">3</span>)</span><br><span class="line">        <span class="comment"># Return the action and action input</span></span><br><span class="line">        <span class="keyword">if</span> action == <span class="string">"Error"</span>:</span><br><span class="line">            <span class="comment"># 这是错误走的通道</span></span><br><span class="line">            error= history.messages[<span class="number">-2</span>]</span><br><span class="line">            <span class="comment"># 方便获取最后的错误内容</span></span><br><span class="line">            action_input =<span class="string">f"<span class="subst">&#123;action&#125;</span>:<span class="subst">&#123;error.content&#125;</span>"</span>;</span><br><span class="line">        <span class="keyword">return</span> AgentAction(tool=action, tool_input=action_input.strip(<span class="string">" "</span>).strip(<span class="string">'"'</span>), log=llm_output)</span><br><span class="line"></span><br><span class="line">output_parser = CustomOutputParser()</span><br><span class="line"></span><br><span class="line">agent = LLMSingleActionAgent(</span><br><span class="line">    llm_chain=llm_chain,</span><br><span class="line">    output_parser=output_parser,</span><br><span class="line">    stop=[<span class="string">"\nObservation:"</span>,<span class="string">"\n\tObservation:"</span>],</span><br><span class="line">)</span><br><span class="line"><span class="comment"># verbose 能控制是否 debug 信息</span></span><br><span class="line">agent_executor = AgentExecutor.from_agent_and_tools(agent=agent,  tools=tools, max_iterations=<span class="number">10</span>, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">input_str = <span class="string">"给我约一个下周五的会议,参会人有我和张金海参会, 我的工号是 076533"</span></span><br><span class="line"><span class="comment"># input_str = "明天给我和王四大建一个早上的会 我的工号是 076533,创建会议等于'拉会','拉'等于创建的意思"</span></span><br><span class="line"><span class="comment"># input_str = "模板 id 为 72 的模板 中, 模块名字包含晋升的模块 id, 看下这个模块的启用状态"</span></span><br><span class="line">history.add_user_message(input_str)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这是输出 token 计算相关信息</span></span><br><span class="line"><span class="keyword">with</span> get_openai_callback() <span class="keyword">as</span> cb:</span><br><span class="line">    result = agent_executor.run(input_str)</span><br><span class="line">    print(<span class="string">f"Total Tokens: <span class="subst">&#123;cb.total_tokens&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">f"Prompt Tokens: <span class="subst">&#123;cb.prompt_tokens&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">f"Completion Tokens: <span class="subst">&#123;cb.completion_tokens&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">f"Total Cost (USD): $<span class="subst">&#123;cb.total_cost&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Final Answer: "</span>,result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除这次推理的记录</span></span><br><span class="line">history.clear()</span><br></pre></td></tr></table></figure><h3 id="日期计算-Tool"><a href="#日期计算-Tool" class="headerlink" title="日期计算 Tool"></a>日期计算 Tool</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.chat <span class="keyword">import</span> (</span><br><span class="line">    ChatPromptTemplate,</span><br><span class="line">    SystemMessagePromptTemplate,</span><br><span class="line">    HumanMessagePromptTemplate,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">dateLLM = ChatOpenAI(temperature=<span class="number">0</span>,model_name=<span class="string">"gpt-3.5-turbo"</span>, verbose=<span class="literal">False</span>) <span class="comment"># type: ignore</span></span><br><span class="line">system_message_prompt = SystemMessagePromptTemplate.from_template(<span class="string">"你将作为一个时间计算器"</span>)</span><br><span class="line">human_template = <span class="string">"""当前时间是北京时间 &#123;time&#125;. 一周中的第一天是周一.每周是 7 天.请一步一步详细分析计算过程的解释(不要任何代码)并给出结果日期时间(北京时间). in format: mm/dd/yyyy</span></span><br><span class="line"><span class="string">问题是:&#123;question&#125;"""</span></span><br><span class="line">human_message_prompt = HumanMessagePromptTemplate.from_template(human_template)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 组装 Prompt</span></span><br><span class="line">chat_prompt = ChatPromptTemplate.from_messages([system_message_prompt, human_message_prompt])</span><br><span class="line">dateChain = LLMChain(llm=dateLLM, prompt=chat_prompt,verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">today = datetime.datetime.now()</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> RedisChatMessageHistory <span class="comment"># type: ignore</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dateCalculator</span><span class="params">(date:str,history:RedisChatMessageHistory)</span>:</span></span><br><span class="line">    <span class="comment"># if '/' not in date or 'mm' in date:</span></span><br><span class="line">    <span class="comment">#     history.add_ai_message("是的冯绍峰格式不对")</span></span><br><span class="line">    <span class="comment">#     return "出错了"</span></span><br><span class="line">    weekday = today.weekday()</span><br><span class="line">    weekday_str = [<span class="string">'星期一'</span>, <span class="string">'星期二'</span>, <span class="string">'星期三'</span>, <span class="string">'星期四'</span>, <span class="string">'星期五'</span>, <span class="string">'星期六'</span>, <span class="string">'星期日'</span>][weekday]</span><br><span class="line">    <span class="comment"># 推断出要计算的日期,有格式限制</span></span><br><span class="line">    result = dateChain.run(time=<span class="string">f"<span class="subst">&#123;today.strftime(<span class="string">'%m/%d/%Y, %H:%M:%S'</span>)&#125;</span>  <span class="subst">&#123;weekday_str&#125;</span>"</span>,question=date)</span><br><span class="line">    <span class="comment"># 计算结果计入记录</span></span><br><span class="line">    history.add_ai_message(result)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;result&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="查询员工信息-Tool"><a href="#查询员工信息-Tool" class="headerlink" title="查询员工信息 Tool"></a>查询员工信息 Tool</h3><p>这里是连了数据库, 通过自然语言转换为 sql</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span>  SQLDatabase, SQLDatabaseChain</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">TODO:</span> 只能给只读权限, 不要让他修改数据.账号权限控制</span></span><br><span class="line">db = SQLDatabase.from_uri(os.environ[<span class="string">'TALENT_DB_DIALECT'</span>],include_tables=[<span class="string">'employees'</span>])</span><br><span class="line"><span class="comment"># talent_position</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain.prompts.prompt <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">_DEFAULT_TEMPLATE = <span class="string">"""Given an input question, first create a syntactically correct &#123;dialect&#125; query to run, then look at the results of the query and return the answer.</span></span><br><span class="line"><span class="string">Use the following format:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Question: "Question here"</span></span><br><span class="line"><span class="string">SQLQuery: "SQL Query to run"</span></span><br><span class="line"><span class="string">SQLResult: "Result of the SQLQuery"</span></span><br><span class="line"><span class="string">Answer: "Final answer here"</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Only use the following tables:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#123;table_info&#125;</span></span><br><span class="line"><span class="string">结果中必须包含每个人的工号(workcode)信息,并解释返回字段数据的含义, 如果没有找到任何结果则只返回Error</span></span><br><span class="line"><span class="string">Question: &#123;input&#125;"""</span></span><br><span class="line">PROMPT = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">"input"</span>, <span class="string">"table_info"</span>, <span class="string">"dialect"</span>], template=_DEFAULT_TEMPLATE</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(temperature=<span class="number">0</span>) <span class="comment"># type: ignore</span></span><br><span class="line">db_chain = SQLDatabaseChain(llm=llm, database=db, prompt=PROMPT,verbose=<span class="literal">True</span>,top_k=<span class="number">3</span>)</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> RedisChatMessageHistory <span class="comment"># type: ignore</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">employeeSearch</span><span class="params">(s:str,history:RedisChatMessageHistory)</span>:</span></span><br><span class="line">    <span class="comment"># 获取他的想法,用想法去转 SQL 比较准.</span></span><br><span class="line">    thought = history.messages[<span class="number">-1</span>]</span><br><span class="line">    <span class="comment"># top_k 参数好像不好使,所以提示语里强制最多 3 条</span></span><br><span class="line">    result = db_chain.run(<span class="string">f"<span class="subst">&#123;thought.content&#125;</span><span class="subst">&#123;s&#125;</span>,最多返回3个"</span>)</span><br><span class="line">    <span class="comment"># 空结果处理</span></span><br><span class="line">    <span class="keyword">if</span>(result.find(<span class="string">'Error'</span>)&gt;=<span class="number">0</span>):</span><br><span class="line">        history.add_ai_message(<span class="string">f"<span class="subst">&#123;thought&#125;</span>:没查询到结果"</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"发生错误"</span></span><br><span class="line">    <span class="comment"># 把结果加入记录</span></span><br><span class="line">    history.add_ai_message(result)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;result&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="日程查询-Tool"><a href="#日程查询-Tool" class="headerlink" title="日程查询 Tool"></a>日程查询 Tool</h3><ul><li>将日期和查询 Tool 得到的结果汇总处理.</li><li>解析出需要的信息</li><li>根据业务逻辑去判断空闲时间,或者日程冲突. 返回结果或者错误处理</li></ul><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> LLMChain, PromptTemplate</span><br><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line"><span class="comment"># 示例</span></span><br><span class="line">example=<span class="string">"""</span></span><br><span class="line"><span class="string">Q: 我的工号是 076533, 小王的工号是 098773, 我和小王要在 04/22/2023 那天 9:30 开个会.</span></span><br><span class="line"><span class="string">A: &#123;</span></span><br><span class="line"><span class="string">    "participant":["076533","098773"],</span></span><br><span class="line"><span class="string">    "meeting_date":"04/22/2023",</span></span><br><span class="line"><span class="string">    "meeting_start_time":"9:30"</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">Q: 我的工号是 076533, 小王的工号是 098773, 我和小王要在 04/22/2023 那天开个会.</span></span><br><span class="line"><span class="string">A: &#123;</span></span><br><span class="line"><span class="string">    "participant":["076533","098773"],</span></span><br><span class="line"><span class="string">    "meeting_date":"04/22/2023",</span></span><br><span class="line"><span class="string">    "meeting_start_time":""</span></span><br><span class="line"><span class="string">   &#125;</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line">template = <span class="string">"""</span></span><br><span class="line"><span class="string">请从以下对话中抽取出 参会人工号, 参会日期, 参会时间. 并以 JSON 格式返回.如果没有明确说明开始时间,则meeting_start_time为"":</span></span><br><span class="line"><span class="string">&#123;example&#125;</span></span><br><span class="line"><span class="string">Q: &#123;chat_history&#125;.</span></span><br><span class="line"><span class="string">A: """</span></span><br><span class="line"></span><br><span class="line">prompt = PromptTemplate(</span><br><span class="line">    input_variables=[<span class="string">"chat_history"</span>,<span class="string">"example"</span>],</span><br><span class="line">    template=template,</span><br><span class="line">)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">concatStr</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;x&#125;</span>\n<span class="subst">&#123;y&#125;</span>"</span></span><br><span class="line"></span><br><span class="line">scheduleLLM = ChatOpenAI(temperature=<span class="number">0</span>,model_name=<span class="string">"gpt-3.5-turbo"</span>, verbose=<span class="literal">False</span>) <span class="comment"># type: ignore</span></span><br><span class="line">dateChain = LLMChain(llm=scheduleLLM, prompt=prompt,verbose=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> RedisChatMessageHistory <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getAvailabelSchedule</span><span class="params">(history:RedisChatMessageHistory)</span>:</span></span><br><span class="line">    <span class="comment"># 把之前的每个工具的问答都集合起来作为参考提示</span></span><br><span class="line">    chat_history = reduce(concatStr,map(<span class="keyword">lambda</span> x:x.content,history.messages)) <span class="comment"># type: ignore</span></span><br><span class="line">    json_str = dateChain.run(chat_history=chat_history,example=example)</span><br><span class="line">    <span class="comment"># result = json.loads(json_str)</span></span><br><span class="line">    <span class="comment"># <span class="doctag">TODO:</span> 这里根据获取的 json 来判断和业务系统通信, 获取空闲时间, 或者报错说冲突</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 记录最终结果</span></span><br><span class="line">    history.add_ai_message(json_str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;json_str&#125;</span>"</span></span><br></pre></td></tr></table></figure><h3 id="Error-Tool"><a href="#Error-Tool" class="headerlink" title="Error Tool"></a>Error Tool</h3><p>当在推断过程中返回 类似<strong>出错了</strong> 这种意思的时候, agent 会选择 Error tool. 此时推断直接结束.<br>Tool 定义中的 <strong>return_direct=True</strong> 代表这个 Tool 返回的结果就直接结束了, 不会让程序再次判断给哪个 Tool 去处理</p><h3 id="Session-模块"><a href="#Session-模块" class="headerlink" title="Session 模块"></a>Session 模块</h3><p>因为没有找到现成的能记录下各个 Tool 里的历史记录和 agent 的记录. 所以独立找 redis 来自己记录了</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> langchain.memory <span class="keyword">import</span> RedisChatMessageHistory <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPgMemory</span><span class="params">(sid:str)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> RedisChatMessageHistory(session_id=sid,url=os.environ[<span class="string">'REDIS_HUI'</span>])</span><br></pre></td></tr></table></figure><h3 id="示例解析过程-debug"><a href="#示例解析过程-debug" class="headerlink" title="示例解析过程(debug)"></a>示例解析过程(debug)</h3><p>这个例子中, 日期推算错误,但格式是对的, 这里只需要针对每个 Tool 去做优化迭代就好了. 整个场景上是跑通的</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">&gt; Entering new AgentExecutor chain...</span><br><span class="line"></span><br><span class="line">Thought: 我需要先计算出下周五的日期</span><br><span class="line">Action: Date Calculator</span><br><span class="line">Action Input: 下周五</span><br><span class="line"></span><br><span class="line">&gt; Entering new LLMChain chain...</span><br><span class="line">Prompt after formatting:</span><br><span class="line">System: 你将作为一个时间计算器</span><br><span class="line">Human: 当前时间是北京时间 04/21/2023, 14:47:38  星期五. 一周中的第一天是周一.每周是 7 天.请一步一步详细分析计算过程的解释(不要任何代码)并给出结果日期时间(北京时间). <span class="keyword">in</span> format: mm/dd/yyyy</span><br><span class="line">问题是:下周五</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observation:首先确定当前是星期五，那么下周五就是本周的第六天再加上一周的时间，即第13天。因为每周是7天，所以我们需要把13除以7得到商和余数，商表示经过了几个完整的周，余数表示在这个周的第几天。</span><br><span class="line"></span><br><span class="line">13 ÷ 7 = 1...6</span><br><span class="line"></span><br><span class="line">因此下周五是第二周的第六天，也就是从当前时间往后推8天的那个星期五。</span><br><span class="line"></span><br><span class="line">当前日期是04/21/2023，那么下周五的日期就是04/29/2023。</span><br><span class="line">Thought:下一步我需要查询参会人的工号和姓名</span><br><span class="line">Action: Search</span><br><span class="line">Action Input: 张金海, 076533</span><br><span class="line"></span><br><span class="line">&gt; Entering new SQLDatabaseChain chain...</span><br><span class="line">下一步我需要查询参会人的工号和姓名张金海, 076533,最多返回3个</span><br><span class="line">SQLQuery:SELECT workcode, name FROM employees WHERE name = <span class="string">'张金海'</span> OR workcode = <span class="string">'076533'</span> LIMIT 3</span><br><span class="line">SQLResult: [(<span class="string">'076533'</span>, <span class="string">'国杰'</span>), (<span class="string">'164733'</span>, <span class="string">'张金海'</span>)]</span><br><span class="line">Answer:返回了两个符合条件的结果，第一个结果的工号为<span class="string">'076533'</span>，姓名为<span class="string">'国杰'</span>，第二个结果的工号为<span class="string">'164733'</span>，姓名为<span class="string">'张金海'</span>。工号和姓名的含义分别为员工的工号和姓名。</span><br><span class="line">&gt; Finished chain.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observation:返回了两个符合条件的结果，第一个结果的工号为<span class="string">'076533'</span>，姓名为<span class="string">'国杰'</span>，第二个结果的工号为<span class="string">'164733'</span>，姓名为<span class="string">'张金海'</span>。工号和姓名的含义分别为员工的工号和姓名。</span><br><span class="line">Thought:下一步我需要查询可用的会议时间</span><br><span class="line">Action: Schedule</span><br><span class="line">Action Input: 04/29/2023</span><br><span class="line"></span><br><span class="line">&gt; Entering new LLMChain chain...</span><br><span class="line">Prompt after formatting:</span><br><span class="line"></span><br><span class="line">请从以下对话中抽取出 参会人工号, 参会日期, 参会时间. 并以 JSON 格式返回.如果没有明确说明开始时间,则meeting_start_time为<span class="string">""</span>:</span><br><span class="line"></span><br><span class="line">Q: 我的工号是 076533, 小王的工号是 098773, 我和小王要在 04/22/2023 那天 9:30 开个会.</span><br><span class="line">A: &#123;</span><br><span class="line">    <span class="string">"participant"</span>:[<span class="string">"076533"</span>,<span class="string">"098773"</span>],</span><br><span class="line">    <span class="string">"meeting_date"</span>:<span class="string">"04/22/2023"</span>,</span><br><span class="line">    <span class="string">"meeting_start_time"</span>:<span class="string">"9:30"</span></span><br><span class="line">   &#125;</span><br><span class="line">Q: 我的工号是 076533, 小王的工号是 098773, 我和小王要在 04/22/2023 那天开个会.</span><br><span class="line">A: &#123;</span><br><span class="line">    <span class="string">"participant"</span>:[<span class="string">"076533"</span>,<span class="string">"098773"</span>],</span><br><span class="line">    <span class="string">"meeting_date"</span>:<span class="string">"04/22/2023"</span>,</span><br><span class="line">    <span class="string">"meeting_start_time"</span>:<span class="string">""</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">Q: 给我约一个下周五的会议,参会人有我和张金海, 我的工号是076533</span><br><span class="line">我需要先计算出下周五的日期</span><br><span class="line">首先确定当前是星期五，那么下周五就是本周的第六天再加上一周的时间，即第13天。因为每周是7天，所以我们需要把13除以7得到商和余数，商表示经过了几个完整的周，余数表示在这个周的第几天。</span><br><span class="line"></span><br><span class="line">13 ÷ 7 = 1...6</span><br><span class="line"></span><br><span class="line">因此下周五是第二周的第六天，也就是从当前时间往后推8天的那个星期五。</span><br><span class="line"></span><br><span class="line">当前日期是04/21/2023，那么下周五的日期就是04/29/2023。</span><br><span class="line">下一步我需要查询参会人的工号和姓名</span><br><span class="line">返回了两个符合条件的结果，第一个结果的工号为<span class="string">'076533'</span>，姓名为<span class="string">'国杰'</span>，第二个结果的工号为<span class="string">'164733'</span>，姓名为<span class="string">'张金海'</span>。工号和姓名的含义分别为员工的工号和姓名。</span><br><span class="line">下一步我需要查询可用的会议时间.</span><br><span class="line">A:</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Observation:&#123;</span><br><span class="line">    <span class="string">"participant"</span>:[<span class="string">"076533"</span>,<span class="string">"164733"</span>],</span><br><span class="line">    <span class="string">"meeting_date"</span>:<span class="string">"04/29/2023"</span>,</span><br><span class="line">    <span class="string">"meeting_start_time"</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&gt; Finished chain.</span><br><span class="line">Total Tokens: 7538</span><br><span class="line">Prompt Tokens: 7107</span><br><span class="line">Completion Tokens: 431</span><br><span class="line">Total Cost (USD): <span class="variable">$0</span>.056440000000000004</span><br><span class="line">Final Answer:  &#123;</span><br><span class="line">    <span class="string">"participant"</span>:[<span class="string">"076533"</span>,<span class="string">"164733"</span>],</span><br><span class="line">    <span class="string">"meeting_date"</span>:<span class="string">"04/29/2023"</span>,</span><br><span class="line">    <span class="string">"meeting_start_time"</span>:<span class="string">""</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h4&gt;&lt;p&gt;先是看到了这个文章: &lt;a href=&quot;https://mp.weixin.qq.com/s/noM8Hy1atF8asuj1Bagpdg&quot;
      
    
    </summary>
    
      <category term="AI" scheme="https://dreambo8563.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="https://dreambo8563.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>GPT学习之PAL</title>
    <link href="https://dreambo8563.github.io/2023/04/17/GPT%E5%AD%A6%E4%B9%A0%E4%B9%8BPAL/"/>
    <id>https://dreambo8563.github.io/2023/04/17/GPT学习之PAL/</id>
    <published>2023-04-17T06:21:31.000Z</published>
    <updated>2023-04-17T06:35:54.701Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://arxiv.org/pdf/2211.10435.pdf" target="_blank" rel="noopener">https://arxiv.org/pdf/2211.10435.pdf</a></p><h3 id="PAL-Program-aided-Language-Models"><a href="#PAL-Program-aided-Language-Models" class="headerlink" title="PAL: Program-aided Language Models"></a>PAL: Program-aided Language Models</h3><p>解释一下, PAL 就是 基于程序辅助的语言模型. 下面例子中具体说怎么个辅助</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们使用 chat-gpt 最重要的部分就是 prompt.</p><p>一般我们使用 prompt 有三种策略</p><ul><li>直接自己造</li><li>chain-of-thought (COT)</li><li>PAL prompting.</li></ul><p>下面直接比较 COT 和 PAL</p><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/pal.png" alt=""></p><blockquote><p>左侧是用的 cot 的方式, 也就是我们常用的<br><code>请一步一步分析,并给出详细的解释过程.</code> + 问题 的方案. 让 gpt 做自己去推理怎么解题.然后在给出答案</p></blockquote><blockquote><p>右侧是 PAL 的方式, 把自然语言的逻辑,转化为可执行的程序,最后通过执行程序来获取结果</p></blockquote><p>文档中重点突出了 PAL 在 <strong>数学, 算法, 比较逻辑等方面</strong>的准确率比 前两种策略更高</p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>下面看 langchain 中的示例来理解 PAL</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> langchain.chains <span class="keyword">import</span> PALChain</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"></span><br><span class="line">llm = ChatOpenAI(model_name=<span class="string">'gpt-3.5-turbo'</span>, temperature=<span class="number">0</span>, max_tokens=<span class="number">512</span>) <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pal_chain = PALChain.from_math_prompt(llm, verbose=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">question = <span class="string">"Jan has three times the number of pets as Marcia. Marcia has two more pets than Cindy. If Cindy has four pets, how many total pets do the three have?"</span></span><br><span class="line"></span><br><span class="line">answer = pal_chain.run(question)</span><br><span class="line">print(<span class="string">"answer: "</span>,answer)</span><br></pre></td></tr></table></figure><p>其实他内置了一个模板来获取可执行的程序</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># flake8: noqa</span></span><br><span class="line"><span class="keyword">from</span> langchain.prompts.prompt <span class="keyword">import</span> PromptTemplate</span><br><span class="line"></span><br><span class="line">template = (</span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">Q: Olivia has $23. She bought five bagels for $3 each. How much money does she have left?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """Olivia has $23. She bought five bagels for $3 each. How much money does she have left?"""</span></span><br><span class="line"><span class="string">    money_initial = 23</span></span><br><span class="line"><span class="string">    bagels = 5</span></span><br><span class="line"><span class="string">    bagel_cost = 3</span></span><br><span class="line"><span class="string">    money_spent = bagels * bagel_cost</span></span><br><span class="line"><span class="string">    money_left = money_initial - money_spent</span></span><br><span class="line"><span class="string">    result = money_left</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he have at the end of wednesday?"""</span></span><br><span class="line"><span class="string">    golf_balls_initial = 58</span></span><br><span class="line"><span class="string">    golf_balls_lost_tuesday = 23</span></span><br><span class="line"><span class="string">    golf_balls_lost_wednesday = 2</span></span><br><span class="line"><span class="string">    golf_balls_left = golf_balls_initial - golf_balls_lost_tuesday - golf_balls_lost_wednesday</span></span><br><span class="line"><span class="string">    result = golf_balls_left</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """There were nine computers in the server room. Five more computers were installed each day, from monday to thursday. How many computers are now in the server room?"""</span></span><br><span class="line"><span class="string">    computers_initial = 9</span></span><br><span class="line"><span class="string">    computers_per_day = 5</span></span><br><span class="line"><span class="string">    num_days = 4  # 4 days between monday and thursday</span></span><br><span class="line"><span class="string">    computers_added = computers_per_day * num_days</span></span><br><span class="line"><span class="string">    computers_total = computers_initial + computers_added</span></span><br><span class="line"><span class="string">    result = computers_total</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: Shawn has five toys. For Christmas, he got two toys each from his mom and dad. How many toys does he have now?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """Shawn has five toys. For Christmas, he got two toys each from his mom and dad. How many toys does he have now?"""</span></span><br><span class="line"><span class="string">    toys_initial = 5</span></span><br><span class="line"><span class="string">    mom_toys = 2</span></span><br><span class="line"><span class="string">    dad_toys = 2</span></span><br><span class="line"><span class="string">    total_received = mom_toys + dad_toys</span></span><br><span class="line"><span class="string">    total_toys = toys_initial + total_received</span></span><br><span class="line"><span class="string">    result = total_toys</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to Denny?"""</span></span><br><span class="line"><span class="string">    jason_lollipops_initial = 20</span></span><br><span class="line"><span class="string">    jason_lollipops_after = 12</span></span><br><span class="line"><span class="string">    denny_lollipops = jason_lollipops_initial - jason_lollipops_after</span></span><br><span class="line"><span class="string">    result = denny_lollipops</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: Leah had 32 chocolates and her sister had 42. If they ate 35, how many pieces do they have left in total?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """Leah had 32 chocolates and her sister had 42. If they ate 35, how many pieces do they have left in total?"""</span></span><br><span class="line"><span class="string">    leah_chocolates = 32</span></span><br><span class="line"><span class="string">    sister_chocolates = 42</span></span><br><span class="line"><span class="string">    total_chocolates = leah_chocolates + sister_chocolates</span></span><br><span class="line"><span class="string">    chocolates_eaten = 35</span></span><br><span class="line"><span class="string">    chocolates_left = total_chocolates - chocolates_eaten</span></span><br><span class="line"><span class="string">    result = chocolates_left</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?"""</span></span><br><span class="line"><span class="string">    cars_initial = 3</span></span><br><span class="line"><span class="string">    cars_arrived = 2</span></span><br><span class="line"><span class="string">    total_cars = cars_initial + cars_arrived</span></span><br><span class="line"><span class="string">    result = total_cars</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: There are 15 trees in the grove. Grove workers will plant trees in the grove today. After they are done, there will be 21 trees. How many trees did the grove workers plant today?</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def solution():</span></span><br><span class="line"><span class="string">    """There are 15 trees in the grove. Grove workers will plant trees in the grove today. After they are done, there will be 21 trees. How many trees did the grove workers plant today?"""</span></span><br><span class="line"><span class="string">    trees_initial = 15</span></span><br><span class="line"><span class="string">    trees_after = 21</span></span><br><span class="line"><span class="string">    trees_added = trees_after - trees_initial</span></span><br><span class="line"><span class="string">    result = trees_added</span></span><br><span class="line"><span class="string">    return result</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Q: &#123;question&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"># solution in Python:</span></span><br><span class="line"><span class="string">'''</span>.strip()</span><br><span class="line">    + <span class="string">"\n\n\n"</span></span><br><span class="line">)</span><br><span class="line">MATH_PROMPT = PromptTemplate(input_variables=[<span class="string">"question"</span>], template=template)</span><br></pre></td></tr></table></figure><p>PALChain 就是把拿到的 py 代码 用 py 的 PythonREPL 来执行并获取到结果</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_call</span><span class="params">(self, inputs: Dict[str, str])</span> -&gt; Dict[str, str]:</span></span><br><span class="line">     llm_chain = LLMChain(llm=self.llm, prompt=self.prompt)</span><br><span class="line">     code = llm_chain.predict(stop=[self.stop], **inputs)</span><br><span class="line">     self.callback_manager.on_text(</span><br><span class="line">         code, color=<span class="string">"green"</span>, end=<span class="string">"\n"</span>, verbose=self.verbose</span><br><span class="line">     )</span><br><span class="line">     repl = PythonREPL(_globals=self.python_globals, _locals=self.python_locals)</span><br><span class="line">     res = repl.run(code + <span class="string">f"\n<span class="subst">&#123;self.get_answer_expr&#125;</span>"</span>)</span><br><span class="line">     output = &#123;self.output_key: res.strip()&#125;</span><br><span class="line">     <span class="keyword">if</span> self.return_intermediate_steps:</span><br><span class="line">         output[<span class="string">"intermediate_steps"</span>] = code</span><br><span class="line">     <span class="keyword">return</span> output</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考资料&quot;&gt;&lt;a href=&quot;#参考资料&quot; class=&quot;headerlink&quot; title=&quot;参考资料&quot;&gt;&lt;/a&gt;参考资料&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://arxiv.org/pdf/2211.10435.pdf&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="AI" scheme="https://dreambo8563.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="https://dreambo8563.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>GPT结合业务探索的思考二</title>
    <link href="https://dreambo8563.github.io/2023/04/16/GPT%E7%BB%93%E5%90%88%E4%B8%9A%E5%8A%A1%E6%8E%A2%E7%B4%A2%E7%9A%84%E6%80%9D%E8%80%83%E4%BA%8C/"/>
    <id>https://dreambo8563.github.io/2023/04/16/GPT结合业务探索的思考二/</id>
    <published>2023-04-16T10:46:16.000Z</published>
    <updated>2023-04-16T11:14:55.653Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇主要是应用了 <strong>数据抽取</strong> 这个 openAI 的能力</p><p>这篇将主要记录 <strong>内容搜索</strong> 的能力的探索过程</p><h4 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h4><p><a href="https://beebom.com/how-train-ai-chatbot-custom-knowledge-base-chatgpt-api/" target="_blank" rel="noopener">https://beebom.com/how-train-ai-chatbot-custom-knowledge-base-chatgpt-api/</a></p><h4 id="langchain"><a href="#langchain" class="headerlink" title="langchain"></a>langchain</h4><p>我们将借用这个探索的机会学习额外的东西</p><ul><li>python</li><li>langchain</li></ul><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>这个流程很多文章都说的很清楚, 这里没很么太多疑义</p><ol><li>把自有知识库分拆成多个 chunk, 每个 chunk 可以向量化存到数据库</li><li>将输入(带 prompt) 也向量化</li><li>用输入从数据库中搜索相近的多个结果</li><li>将结果和原始问题 拼接, 结果作为参考资料, 让 gpt 回答</li></ol><h4 id="创建基础的能力"><a href="#创建基础的能力" class="headerlink" title="创建基础的能力"></a>创建基础的能力</h4><ol><li>获取用户的输入</li><li>加入 prompt 并想 openAI 获取结果</li></ol><p>这是基本流程的建立, 直接看 langchain 官网即可<br><a href="https://python.langchain.com/en/latest/" target="_blank" rel="noopener">https://python.langchain.com/en/latest/</a></p><p>开始我想试下 js 版本,但遇到了点困难, 和 openAI 打不通, 感觉是源码里打的对应的 api 地址不对造成的. 也可能我哪里没配置对. 后来索性就想顺便学点 python 也好.<br>毕竟在 AI 这个生态里, python 可以说是让不过去的门槛.</p><h4 id="读取自有的知识库-并存储到向量数据库"><a href="#读取自有的知识库-并存储到向量数据库" class="headerlink" title="读取自有的知识库,并存储到向量数据库"></a>读取自有的知识库,并存储到向量数据库</h4><p><a href="https://python.langchain.com/en/latest/modules/indexes.html" target="_blank" rel="noopener">https://python.langchain.com/en/latest/modules/indexes.html</a></p><p>这里的两个步骤是连续的, 因为都和存储的组件相关</p><ul><li>读取文件存到数据库</li><li>根据输入从数据库里搜索到相似的内容</li></ul><h5 id="选择安装存储组件"><a href="#选择安装存储组件" class="headerlink" title="选择安装存储组件"></a>选择安装存储组件</h5><p>这里我花费的时间有点多(大概是半天).</p><ol><li>Chroma 看到时直接放内存的,我估计会比较简单搭建,让程序跑起来, 最后发现我的 MBP 的 cpu 不合适, 安装不上而放弃</li><li>先看到有 redis 支持. 就拿现有的测试环境数据库尝试,发现不支持. 一直失败, 开始以为是 redis 版本不够. 后续发现应该是需要额外模块才行.<br><a href="https://redis.io/docs/stack/search/" target="_blank" rel="noopener">https://redis.io/docs/stack/search/</a> - 应该是要安装这个模块才行,还未尝试</li><li>又看到 ES 可以支持. 也是想直接用项目上现有的测试 ES.发现应该是版本不够. 我们是 7.9. 从提示看起码需要 8. 放弃</li><li>最后一个还算比较熟悉的就是 postgres 了</li></ol><p>很多时间都花在更新 homebrew 了. homebrew 直接安装 postgres@14 这个过程还好,缺啥装啥就行了. 当然 mac 自带的 python 是 2.x. 需要先装 3.x 和对应 pip<br>然后需要安装 向量化插件 <a href="https://python.langchain.com/en/latest/modules/indexes/vectorstores/examples/pgvector.html" target="_blank" rel="noopener">https://python.langchain.com/en/latest/modules/indexes/vectorstores/examples/pgvector.html</a><br>还要在 db 中执行插件命令 <code>CREATE EXTENSION vector</code></p><p>基础设施基本有了, 才能把代码逻辑连上</p><h5 id="下面解决导入的问题"><a href="#下面解决导入的问题" class="headerlink" title="下面解决导入的问题"></a>下面解决导入的问题</h5><p>这个比较顺利. 尝试了比较普遍的格式</p><ul><li>txt</li><li>pdf</li></ul><p>这里没遇到明显的困难, 运行报错基本都是有些依赖包没安装</p><p>中间有些 prompt 的细节最后看代码注释就明白了, 我也尝试看了下向量化的结果,真的看不懂,非常多的维度坐标来表示一段话的核心含义</p><p>这些向量化数据库都具备搜索的 api,所以这步不用说了<br>导入执行成功后, 那段代码就需要注释掉, 否则每次执行都会导入一遍,数据库里有会重复信息</p><p>可以通过如下 sql 查看导入的向量化数据</p><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> information_schema.tables <span class="keyword">WHERE</span> table_schema = <span class="string">'public'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> langchain_pg_embedding</span><br></pre></td></tr></table></figure><h5 id="最后看了开始的参考文章加了-gradio-这个-UI"><a href="#最后看了开始的参考文章加了-gradio-这个-UI" class="headerlink" title="最后看了开始的参考文章加了 gradio 这个 UI."></a>最后看了开始的参考文章加了 gradio 这个 UI.</h5><p>基本上我想探索的搜索能力都具备了</p><p>代码很少</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> gradio <span class="keyword">as</span> gr</span><br><span class="line"><span class="keyword">from</span> langchain.prompts.chat <span class="keyword">import</span> (</span><br><span class="line">    ChatPromptTemplate,</span><br><span class="line">    SystemMessagePromptTemplate,</span><br><span class="line">    HumanMessagePromptTemplate,</span><br><span class="line">)</span><br><span class="line"><span class="keyword">from</span> langchain <span class="keyword">import</span> LLMChain</span><br><span class="line"><span class="keyword">from</span> langchain.chat_models <span class="keyword">import</span> ChatOpenAI</span><br><span class="line"><span class="keyword">from</span> langchain.docstore.document <span class="keyword">import</span> Document</span><br><span class="line"><span class="keyword">from</span> langchain.vectorstores.pgvector <span class="keyword">import</span> PGVector</span><br><span class="line"><span class="keyword">from</span> langchain.text_splitter <span class="keyword">import</span> CharacterTextSplitter</span><br><span class="line"><span class="keyword">from</span> langchain.embeddings.openai <span class="keyword">import</span> OpenAIEmbeddings</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List, Tuple</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> dotenv <span class="keyword">import</span> load_dotenv</span><br><span class="line">load_dotenv()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">chatbot</span><span class="params">(input_text)</span>:</span></span><br><span class="line">    <span class="comment"># load txt</span></span><br><span class="line">    <span class="comment"># from langchain.document_loaders import TextLoader</span></span><br><span class="line">    <span class="comment"># loader = TextLoader('./zhiyin.txt')</span></span><br><span class="line">    <span class="comment"># documents = loader.load()</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># load pdf</span></span><br><span class="line">    <span class="comment"># from langchain.document_loaders import PDFMinerLoader</span></span><br><span class="line">    <span class="comment"># loader = PDFMinerLoader("./1.pdf")</span></span><br><span class="line">    <span class="comment"># documents = loader.load()</span></span><br><span class="line"></span><br><span class="line">    documents = []</span><br><span class="line"></span><br><span class="line">    text_splitter = CharacterTextSplitter(</span><br><span class="line">        chunk_size=<span class="number">500</span>, separator=<span class="string">"\n"</span>, chunk_overlap=<span class="number">0</span>)</span><br><span class="line">    docs = text_splitter.split_documents(documents)</span><br><span class="line"></span><br><span class="line">    embeddings = OpenAIEmbeddings()  <span class="comment"># type: ignore</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># PGVector needs the connection string to the database.</span></span><br><span class="line"><span class="comment"># We will load it from the environment variables.</span></span><br><span class="line"></span><br><span class="line">    CONNECTION_STRING = PGVector.connection_string_from_db_params(</span><br><span class="line">        driver=os.environ.get(<span class="string">"PGVECTOR_DRIVER"</span>, <span class="string">"psycopg2"</span>),</span><br><span class="line">        host=os.environ.get(<span class="string">"PGVECTOR_HOST"</span>, <span class="string">"localhost"</span>),</span><br><span class="line">        port=int(os.environ.get(<span class="string">"PGVECTOR_PORT"</span>, <span class="string">"5432"</span>)),</span><br><span class="line">        database=os.environ.get(<span class="string">"PGVECTOR_DATABASE"</span>, <span class="string">"postgres"</span>),</span><br><span class="line">        user=os.environ.get(<span class="string">"PGVECTOR_USER"</span>, <span class="string">"vincent"</span>),</span><br><span class="line">        password=os.environ.get(<span class="string">"PGVECTOR_PASSWORD"</span>, <span class="string">""</span>),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># The PGVector Module will try to create a table with the name of the collection. So, make sure that the collection name is unique and the user has the</span></span><br><span class="line"><span class="comment"># permission to create a table.</span></span><br><span class="line"><span class="comment"># load doc into gp and create embedding</span></span><br><span class="line">    db = PGVector.from_documents(</span><br><span class="line">        embedding=embeddings,</span><br><span class="line">        documents=docs,</span><br><span class="line">        collection_name=<span class="string">"kaoqin"</span>,</span><br><span class="line">        connection_string=CONNECTION_STRING,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    query = input_text</span><br><span class="line">    docs_with_score: List[Tuple[Document, float]] = db.similarity_search_with_score(query, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">    dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    resultStr: str = <span class="string">""</span></span><br><span class="line">    print(<span class="string">"*"</span>*<span class="number">80</span>)</span><br><span class="line">    <span class="keyword">for</span> doc, score <span class="keyword">in</span> docs_with_score:</span><br><span class="line">        <span class="keyword">if</span> dict.get(score) == <span class="literal">None</span>:</span><br><span class="line">            <span class="comment"># remove the same score content</span></span><br><span class="line">            dict[score] = doc.page_content</span><br><span class="line">            print(<span class="string">"score"</span>,score)</span><br><span class="line">            print(<span class="string">"page_content"</span>,doc.page_content)</span><br><span class="line">            resultStr += doc.page_content</span><br><span class="line">            <span class="comment"># compose all text</span></span><br><span class="line">            print(<span class="string">"*"</span>*<span class="number">80</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    system_message_prompt = SystemMessagePromptTemplate.from_template(</span><br><span class="line">        <span class="string">"你将作为一个问答知识库,根据提出的问题给出回答和相关参考信息.回答字数不超过 1000 字符"</span>)</span><br><span class="line">    human_template = <span class="string">"""</span></span><br><span class="line"><span class="string">    参考信息:&#123;reference&#125;</span></span><br><span class="line"><span class="string">    问题是:&#123;question&#125;</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    human_message_prompt = HumanMessagePromptTemplate.from_template(</span><br><span class="line">        human_template)</span><br><span class="line"></span><br><span class="line">    chat_prompt = ChatPromptTemplate.from_messages(</span><br><span class="line">        [system_message_prompt, human_message_prompt])</span><br><span class="line"></span><br><span class="line">    chat = ChatOpenAI(</span><br><span class="line">        temperature=<span class="number">0.5</span>, model_name=<span class="string">"gpt-3.5-turbo"</span>)  <span class="comment"># type: ignore</span></span><br><span class="line">    chain = LLMChain(llm=chat, prompt=chat_prompt)</span><br><span class="line">    <span class="comment"># compose question and reference and send to gpt</span></span><br><span class="line">    print(<span class="string">"question:"</span>, query)</span><br><span class="line">    <span class="comment"># print("chatGPT:", chain.run(reference=resultStr[0:2000], question=query))</span></span><br><span class="line"></span><br><span class="line">    answer = chain.run(reference=resultStr[<span class="number">0</span>:<span class="number">2000</span>], question=query)</span><br><span class="line">    print(<span class="string">"answer:"</span> ,answer)</span><br><span class="line">    <span class="keyword">return</span>  answer</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iface = gr.Interface(fn=chatbot,</span><br><span class="line">                     inputs=gr.components.Textbox(</span><br><span class="line">                         lines=<span class="number">14</span>, label=<span class="string">"Enter your text"</span>),</span><br><span class="line">                     outputs=gr.components.Textbox(</span><br><span class="line">                         lines=<span class="number">14</span>),</span><br><span class="line">                     title=<span class="string">"Custom-trained AI Chatbot"</span>)</span><br><span class="line"></span><br><span class="line">iface.launch(share=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇主要是应用了 &lt;strong&gt;数据抽取&lt;/strong&gt; 这个 openAI 的能力&lt;/p&gt;
&lt;p&gt;这篇将主要记录 &lt;strong&gt;内容搜索&lt;/strong&gt; 的能力的探索过程&lt;/p&gt;
&lt;h4 id=&quot;参考文章&quot;&gt;&lt;a href=&quot;#参考文章&quot; class=&quot;head
      
    
    </summary>
    
      <category term="AI" scheme="https://dreambo8563.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="https://dreambo8563.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>GPT结合业务探索的思考一</title>
    <link href="https://dreambo8563.github.io/2023/04/16/GPT%E7%BB%93%E5%90%88%E4%B8%9A%E5%8A%A1%E6%8E%A2%E7%B4%A2%E7%9A%84%E6%80%9D%E8%80%83%E4%B8%80/"/>
    <id>https://dreambo8563.github.io/2023/04/16/GPT结合业务探索的思考一/</id>
    <published>2023-04-16T10:21:26.000Z</published>
    <updated>2023-04-16T10:42:48.412Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近 Chatgpt 的推迟和相关应用业务的火爆, 需要让我们也必须跟上脚步, 不管是开发上还是业务上都必须对当期 AI 的能力有所了解, 并且开始探索也应用.</p><h3 id="探索应用场景"><a href="#探索应用场景" class="headerlink" title="探索应用场景"></a>探索应用场景</h3><p>内部成立的 gpt 的实验项目, 恰巧当时我也开始思考了一些, 所以给出了应对 “请假” 这个内部系统场景的方案.</p><p><strong>用户的自然语言</strong> -&gt; 通过数据抽取 -&gt; 程序语言(可执行代码/数据结构)</p><p>因为要和现有业务规则融合, 我们选择申请一个助理机器人作为 AI 的入口</p><blockquote><p>优势</p></blockquote><ul><li>独立原有的业务项目, 可以独立添加一个入口, 也意味着可以独立下掉(对未来政策的担心)</li><li>更接近我们的目标, Jarvis</li></ul><h4 id="初次获取数据场景"><a href="#初次获取数据场景" class="headerlink" title="初次获取数据场景"></a>初次获取数据场景</h4><p>将 “我下周一请半天假” 转为 JSON 结构返给业务程序</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"事假"</span>,</span><br><span class="line">  <span class="attr">"startDate"</span>: <span class="string">"yyy-mm-dd"</span>,</span><br><span class="line">  <span class="attr">"startTime"</span>: <span class="string">"上午"</span>,</span><br><span class="line">  <span class="attr">"days"</span>: <span class="number">0.5</span>,</span><br><span class="line">  <span class="attr">"reason"</span>: <span class="string">"有事要处理"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>prompt</p></blockquote><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请开启一个新会话,不要和之前内容关联</span><br><span class="line">当前时间是北京时间2023年04月13日 18:48:53 周四，你将作为一个语言转换器,你的任务是从下面给出的文本中提取出以下内容：请假类型、开始日期、开始时间、请假天数、请假原因，请提取出精确的表达。请假类型包括病假、年假、婚假、产检假、产假、丧假、流产假、陪产假、公益日、育儿假、护理假、调休.如果没有明确说明类型,需要根据描述或者请假原因来推断出最可能的类型. 如果无法推断出已知类型中就认为是事假。</span><br><span class="line"></span><br><span class="line">身体不适属于病假;</span><br><span class="line"></span><br><span class="line">如果没有明确说明请假原因，你可以适当发挥你的创造力。如果实在没有原因请返回 null</span><br><span class="line"></span><br><span class="line">开始时间只能为上午或者下午，如果没有明确说明是上午或者下午，那么就是上午。</span><br><span class="line"></span><br><span class="line">请假天数以0.5天为单位，返回一个不包括单位的数字。</span><br><span class="line">如果只说明上午或下午，那么请假天数是0.5;</span><br><span class="line">例如： 下午要请假. 请假天数你应该取到0.5。</span><br><span class="line">如果没有分析出明确的请假天数,但描述中提到多个具体的日期那么请假天数是最大日期减去最小日期的差+1;</span><br><span class="line">例如我请17号18号的年假,请假天数为 2.</span><br><span class="line">如果没有分析出明确的请假天数也没有明确的日期,那么请假天数是1.</span><br><span class="line">例如：我请个事假,请假天数为 1.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">星期一是每周的第一天.</span><br><span class="line">如果请假类型是婚假，那请假天数必须是10。</span><br><span class="line">将结果返回一个JSON对象，type字段是请假类型，startDate字段是开始日期，startTime字段是开始时间，days字段是请假天数，reason字段是请假原因，不需要返回多余的信息。如果提供了当前数据，则在当前数据基础上重新提取后返回新JSON对象。</span><br><span class="line"></span><br><span class="line">下面是你需要处理的文本：我明天要请个假，想回趟家</span><br></pre></td></tr></table></figure><h4 id="对现有数据修改的场景"><a href="#对现有数据修改的场景" class="headerlink" title="对现有数据修改的场景"></a>对现有数据修改的场景</h4><ul><li>获取到上一次解析出的 JSON, 并作为参考,让 gpt 修改. 这样做可以保证我们 prompt 的 token 数量是一定的. 不会持续的增加. 又能让用户和机器人进行多轮的对话</li></ul><p>原有 prompt 里,这句话是重点</p><blockquote><p>如果提供了当前数据，则在当前数据基础上重新提取后返回新 JSON 对象。</p></blockquote><h4 id="针对复杂场景的引导方案"><a href="#针对复杂场景的引导方案" class="headerlink" title="针对复杂场景的引导方案"></a>针对复杂场景的引导方案</h4><p>有些场景 gpt 无法根据 prompt 来返回预期的解析内容<br>有些难点</p><ul><li>prompt 的修改难度比较大</li><li>规则逻辑可能本身就很复杂,即使给出一些示例, gpt 依然无法严格执行</li></ul><p>我么需要借鉴现在很多主流项目的方案:<br>引导 gpt 对输入进行分析, 比如先让 gpt 根据输入思考下依赖什么信息, 带上依赖的信息进行最终的询问. 用程序和 gpt 直接多轮的对话来获取最终比较准确的答案.</p><p>这个是参考 MS 的 Jarvis 项目. 他说将用户的任务先让 gpt 进行任务拆分, 拆分出依赖的子任务. 然后去各自询问子任务的结果, 等依赖任务都得到结果后再按顺序执行任务, 以得到最终的结果</p><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>当 gpt 对某个 case 的输入理解不正确的时候, 我们可以</p><blockquote><p><strong>请一步一步进行分析,并详细给出解释</strong>. 下面是你需要处理的文本：我明天要请个假，想回趟家<br>看到 gpt 的具体分析过程, 也就能大致判断出我们 prompt 哪里让他误解,或者他没明白,没记住. 也是我们后续可以让他推理的方向</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近 Chatgpt 的推迟和相关应用业务的火爆, 需要让我们也必须跟上脚步, 不管是开发上还是业务上都必须对当期 AI 的能力有所了解, 
      
    
    </summary>
    
      <category term="AI" scheme="https://dreambo8563.github.io/categories/AI/"/>
    
    
      <category term="AI" scheme="https://dreambo8563.github.io/tags/AI/"/>
    
  </entry>
  
  <entry>
    <title>AndOrParser</title>
    <link href="https://dreambo8563.github.io/2022/07/14/AndOrParser/"/>
    <id>https://dreambo8563.github.io/2022/07/14/AndOrParser/</id>
    <published>2022-07-14T08:44:00.000Z</published>
    <updated>2022-07-14T10:12:03.839Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AndOrPaser"><a href="#AndOrPaser" class="headerlink" title="AndOrPaser"></a>AndOrPaser</h1><p><a href="https://github.com/dreambo8563/AndOrPaser" target="_blank" rel="noopener">https://github.com/dreambo8563/AndOrPaser</a></p><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/parser.png" alt=""></p><h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>用户需要手写表达式 类似 <code>((规则3 and 规则1) AND (规则2 or 规则4) or (规则5 and  规则6))</code>, 接口会根据表达式配置的条件提取数据</p><ul><li>每一个规则都是在页面里配置的数据维度例如</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> data:IContext=&#123;</span><br><span class="line">  <span class="string">"规则3"</span>:&#123;</span><br><span class="line">    prop:<span class="string">"level"</span>,</span><br><span class="line">    operator:<span class="string">"in"</span>,</span><br><span class="line">    value:[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"规则1"</span>:&#123;</span><br><span class="line">    prop:<span class="string">"workcode"</span>,</span><br><span class="line">    operator:<span class="string">"="</span>,</span><br><span class="line">    value:<span class="string">"076533"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"规则2"</span>:&#123;</span><br><span class="line">    prop:<span class="string">"department_ids"</span>,</span><br><span class="line">    operator:<span class="string">"!="</span>,</span><br><span class="line">    value:<span class="string">"D011111"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"规则4"</span>:&#123;</span><br><span class="line">    prop:<span class="string">"department_ids"</span>,</span><br><span class="line">    operator:<span class="string">"="</span>,</span><br><span class="line">    value:<span class="string">"D22222"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"规则5"</span>:&#123;</span><br><span class="line">    prop:<span class="string">"age"</span>,</span><br><span class="line">    operator:<span class="string">"&gt;="</span>,</span><br><span class="line">    value:<span class="number">18</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"规则6"</span>:&#123;</span><br><span class="line">    prop:<span class="string">"isManager"</span>,</span><br><span class="line">    operator:<span class="string">"="</span>,</span><br><span class="line">    value:<span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="parse-的流程"><a href="#parse-的流程" class="headerlink" title="parse 的流程"></a>parse 的流程</h4><ol><li><p>将输入的 string  =&gt; 输入流, 提供了基本的 next(获取下一个字符), peek(当前字符), eof(是否结束),croak(报错) 方法</p></li><li><p>将输入流转化为 token 流, 也 就是<strong>词法分析</strong>. 把字符提取为独立的Token</p></li></ol><ul><li>kw 为关键词 -&gt; 这里支持 <strong>and</strong> 和 <strong>or</strong> 两个操作符 作为关键词</li><li>var 为变量 -&gt; 这里规定用户只能输入 <em>规则+数字</em> 的格式, 类似 <em>规则1</em></li><li>punc 为标点 -&gt; 这里只可以存在 () 作为标点</li></ul><ol start="3"><li><p>将token 流转化为 ast 进行解析</p></li><li><p>将 ast和配置的维度数据 解释 为 sql 语句的条件部分</p></li></ol><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> ast =parser(<span class="string">"((规则3 and 规则1) AND (规则2 or 规则4) or (规则5 and  规则6))"</span>)</span><br></pre></td></tr></table></figure><p>AST 为:<br><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"expression"</span>,</span><br><span class="line">  <span class="attr">"left"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"expression"</span>,</span><br><span class="line">    <span class="attr">"left"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"expression"</span>,</span><br><span class="line">      <span class="attr">"left"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"var"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"规则3"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"operator"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"kw"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"and"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"right"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"var"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"规则1"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"operator"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"kw"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"AND"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"right"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"expression"</span>,</span><br><span class="line">      <span class="attr">"left"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"var"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"规则2"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"operator"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"kw"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"or"</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">"right"</span>: &#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"var"</span>,</span><br><span class="line">        <span class="attr">"value"</span>: <span class="string">"规则4"</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"operator"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"kw"</span>,</span><br><span class="line">    <span class="attr">"value"</span>: <span class="string">"or"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"right"</span>: &#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"expression"</span>,</span><br><span class="line">    <span class="attr">"left"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"var"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"规则5"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"operator"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"kw"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"and"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"right"</span>: &#123;</span><br><span class="line">      <span class="attr">"type"</span>: <span class="string">"var"</span>,</span><br><span class="line">      <span class="attr">"value"</span>: <span class="string">"规则6"</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>astString(ast)</strong> 会将 ast 解释为原表达式, 只不过会加上没有的(), <strong>and</strong> 和 <strong>or</strong> 是从左到右的优先级.</p><blockquote><p><strong>(</strong>((规则3 and 规则1) AND (规则2 or 规则4)<strong>)</strong> or (规则5 and 规则6))</p></blockquote><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">evaluate(ast,data)</span><br></pre></td></tr></table></figure><p><strong>evaluate</strong> 会真正解释为 sql 条件</p><blockquote><p>(((level in (1,2,3) and workcode = “076533”) AND (department_ids != “D011111” or department_ids = “D22222”)) or (age &gt;= 18 and isManager = 1))</p></blockquote><h3 id="本地运行"><a href="#本地运行" class="headerlink" title="本地运行"></a>本地运行</h3><p>用的 ts 编写, 本地需要安装 typescript</p><p><code>tsc main.ts &amp;&amp; node main.js</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;AndOrPaser&quot;&gt;&lt;a href=&quot;#AndOrPaser&quot; class=&quot;headerlink&quot; title=&quot;AndOrPaser&quot;&gt;&lt;/a&gt;AndOrPaser&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/dreambo856
      
    
    </summary>
    
      <category term="TypeScript" scheme="https://dreambo8563.github.io/categories/TypeScript/"/>
    
    
      <category term="TypeScript" scheme="https://dreambo8563.github.io/tags/TypeScript/"/>
    
      <category term="parser" scheme="https://dreambo8563.github.io/tags/parser/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Mixin-RenderTrack</title>
    <link href="https://dreambo8563.github.io/2022/04/15/Vue-Mixin-RenderTrack/"/>
    <id>https://dreambo8563.github.io/2022/04/15/Vue-Mixin-RenderTrack/</id>
    <published>2022-04-15T08:04:13.000Z</published>
    <updated>2022-04-18T06:54:50.391Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>开始使用 vue 3.x 开发项目, 并使用 pinia 等相关新的生态 并阅读相关文档</li><li>希望基于 vue 3 写点代码, 用了 新的 dev_tools, 功能丰富了很多. </li><li>最近几个项目里都遇到了不同情况下的性能问题</li></ul><h3 id="RenderTracker-的作用"><a href="#RenderTracker-的作用" class="headerlink" title="RenderTracker 的作用"></a>RenderTracker 的作用</h3><p>vue 3 生命周期 onRenderTriggered 文档</p><blockquote><p>Registers a debug hook to be called when a reactive dependency triggers the component’s render effect to be re-run. 是一个 debug 模式下的 hook, 会因为响应式的依赖触发组件的重新渲染</p></blockquote><p><a href="https://vuejs.org/api/composition-api-lifecycle.html#onrendertriggered" target="_blank" rel="noopener">https://vuejs.org/api/composition-api-lifecycle.html#onrendertriggered</a></p><p>综合文档看, 这个 hook 比较适合查看是否某些组件过多的频繁渲染, 并给出一些简单的信息协助定位问题</p><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>因为这个工具的注入是针对所有的组件为目标的</p><p><strong>但是:</strong> vue 3.x 本身似乎没有提供, 也不提倡这种全局的无差别注入, 特别是咱们还想注入到 hook 中让它自动执行</p><blockquote><p>In Vue 2, mixins were the primary mechanism for creating reusable chunks of component logic. While mixins continue to be supported in Vue 3, Composition API is now the preferred approach for code reuse between components.</p></blockquote><p>从某些方面看, vue 3.x 并没有完全覆盖 vue 2.x 的所有能力. 比如 <a href="https://vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance" target="_blank" rel="noopener">https://vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance</a></p><p>所以这个小工具使用 options 的写法来注入还是可以理解的</p><h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/b83a75ae9a588cf71ebc43605128fdab51579dba/renderTrack.png" alt=""></p><p>输出信息包含 3 种组件分类:</p><ul><li><p>路由组件</p><blockquote><p>可以输出当时的路由信息</p></blockquote></li><li><p>具名组件 (可以获取名字的,一般来说 组件库的都是有名字的)</p><blockquote><p>图中未包含,只是显示名字,只需要看哪些是否触发非常频繁就足够了</p></blockquote></li><li><p>无名组件 (一般都是业务自己写的)</p><blockquote><p>会输出 操作类型 / key / value , 并可以展开 trace 信息协助定位到具体代码位置</p></blockquote></li></ul><h3 id="工具实现"><a href="#工具实现" class="headerlink" title="工具实现"></a>工具实现</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  <span class="keyword">type</span> ComponentPublicInstance,</span><br><span class="line">  <span class="keyword">type</span> DebuggerEvent,</span><br><span class="line">  <span class="keyword">type</span> Ref,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; RouteLocationNormalizedLoaded &#125; <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RenderTrackOptions &#123;</span><br><span class="line">  exclusive: RenderTrackKind[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> RenderTrackKind &#123;</span><br><span class="line">  Router, <span class="comment">// 路由组件</span></span><br><span class="line">  NamedComponent, <span class="comment">// 具名组件</span></span><br><span class="line">  UnnamedComponent, <span class="comment">// 无名组件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> commonStyle = [<span class="string">"color: gray"</span>, <span class="string">"padding: 3px 5px"</span>, <span class="string">"border-radius:10px"</span>];</span><br><span class="line"><span class="keyword">const</span> style = [...commonStyle, <span class="string">"background: greenyellow"</span>].join(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pageStyle = [<span class="string">"background: gold"</span>, ...commonStyle].join(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routerStyle = [<span class="string">"background: #ef94ff"</span>, ...commonStyle].join(<span class="string">";"</span>);</span><br><span class="line"><span class="keyword">const</span> renderStyle = [...commonStyle, <span class="string">"background:#de4242"</span>, <span class="string">"color:black"</span>].join(</span><br><span class="line">  <span class="string">";"</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  options: RenderTrackOptions = &#123;</span><br><span class="line">    exclusive: [],</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt;</span><br><span class="line">  defineComponent(&#123;</span><br><span class="line">    renderTriggered(e: DebuggerEvent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        options.exclusive.length ==</span><br><span class="line">        [</span><br><span class="line">          RenderTrackKind.NamedComponent,</span><br><span class="line">          RenderTrackKind.Router,</span><br><span class="line">          RenderTrackKind.UnnamedComponent,</span><br><span class="line">        ].length</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 如果所有类型都被排除, 则无需执行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [runUnnamedComponent, runRoute, runNamedComponent].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn(options, <span class="keyword">this</span>, e)) &#123;</span><br><span class="line">          <span class="comment">// 有一个匹配的就中断</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeUpdate() &#123;</span><br><span class="line">      <span class="keyword">const</span> name = extractFileName(<span class="keyword">this</span>.$options.__file);</span><br><span class="line">      <span class="keyword">if</span> (name) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(</span><br><span class="line">          <span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x26a1</span>)&#125;</span> <span class="subst">$&#123;name&#125;</span> Render`</span>,</span><br><span class="line">          renderStyle</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 trace 路径获取到文件名</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; [filePath]</span></span><br><span class="line"><span class="comment"> * @returns &#123;string&#125; 文件名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractFileName</span>(<span class="params">filePath?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = filePath || <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">const</span> arr = p.split(<span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runRoute</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RenderTrackOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentComponent: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  e: DebuggerEvent</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件名字</span></span><br><span class="line">  <span class="keyword">let</span> name =</span><br><span class="line">    currentComponent.$options.name || currentComponent.$options._componentTag;</span><br><span class="line">  <span class="comment">// 判断是否是路由, 或者用 (e.target as Ref&lt;RouteLocationNormalizedLoaded&gt;)?.value?.fullPath 来判断</span></span><br><span class="line">  <span class="keyword">const</span> isRouter = name == <span class="string">"RouterView"</span>;</span><br><span class="line">  <span class="keyword">const</span> hasPermission = !options.exclusive.includes(RenderTrackKind.Router);</span><br><span class="line">  <span class="keyword">if</span> (isRouter &amp;&amp; hasPermission) &#123;</span><br><span class="line">    <span class="comment">// 输出路由组件信息</span></span><br><span class="line">    <span class="keyword">const</span> route = (e.target <span class="keyword">as</span> Ref&lt;RouteLocationNormalizedLoaded&gt;).value;</span><br><span class="line">    name = <span class="string">`Router: <span class="subst">$&#123;route.fullPath || route.path&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(</span><br><span class="line">      <span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f6b4</span>)&#125;</span> <span class="subst">$&#123;name&#125;</span> `</span>,</span><br><span class="line">      routerStyle</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f308</span>)&#125;</span> Route`</span>, route);</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runNamedComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RenderTrackOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentComponent: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  _: DebuggerEvent</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件名字</span></span><br><span class="line">  <span class="keyword">const</span> name =</span><br><span class="line">    currentComponent.$options.name || currentComponent.$options._componentTag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hasPermission = !options.exclusive.includes(</span><br><span class="line">    RenderTrackKind.NamedComponent</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name &amp;&amp; hasPermission) &#123;</span><br><span class="line">    <span class="comment">// 输出具名组件信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f6b4</span>)&#125;</span> <span class="subst">$&#123;name&#125;</span> `</span>, style);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runUnnamedComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RenderTrackOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentComponent: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  e: DebuggerEvent</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件名字</span></span><br><span class="line">  <span class="keyword">const</span> name =</span><br><span class="line">    currentComponent.$options.name || currentComponent.$options._componentTag;</span><br><span class="line">  <span class="keyword">const</span> hasPermission = !options.exclusive.includes(</span><br><span class="line">    RenderTrackKind.UnnamedComponent</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!name &amp;&amp; hasPermission) &#123;</span><br><span class="line">    <span class="comment">// 输出无名组件信息</span></span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(</span><br><span class="line">      <span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f6b4</span>)&#125;</span> <span class="subst">$&#123;extractFileName(</span></span></span><br><span class="line"><span class="string"><span class="subst">        currentComponent.$options.__file</span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span>`</span>,</span><br><span class="line">      pageStyle</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f91c</span>)&#125;</span> <span class="subst">$&#123;e.<span class="keyword">type</span>.toUpperCase()&#125;</span> [<span class="subst">$&#123;e.key&#125;</span>] `</span>,</span><br><span class="line">      e.newValue || (e.target <span class="keyword">as</span> Ref&lt;unknown&gt;).value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(<span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f308</span>)&#125;</span> Trace`</span>);</span><br><span class="line">    <span class="built_in">console</span>.trace(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入使用"><a href="#注入使用" class="headerlink" title="注入使用"></a>注入使用</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除具名(大部分是组件库)组件的信息, 默认是都不排除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.meta.env.DEV) &#123;</span><br><span class="line">  app.mixin(</span><br><span class="line">    renderTrack(&#123;</span><br><span class="line">      exclusive: [RenderTrackKind.NamedComponent],</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部输出</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.meta.env.DEV) &#123;</span><br><span class="line">  app.mixin(</span><br><span class="line">    renderTrack()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;开始使用 vue 3.x 开发项目, 并使用 pinia 等相关新的生态 并阅读相关文档&lt;/li&gt;
&lt;li&gt;希望基于 vue 3
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
      <category term="mixin" scheme="https://dreambo8563.github.io/tags/mixin/"/>
    
  </entry>
  
  <entry>
    <title>vue-async-click</title>
    <link href="https://dreambo8563.github.io/2022/03/31/vue-async-click/"/>
    <id>https://dreambo8563.github.io/2022/03/31/vue-async-click/</id>
    <published>2022-03-31T07:00:13.000Z</published>
    <updated>2022-03-31T08:11:14.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><blockquote><p>我们经常遇到 <code>点击</code> 按钮来触发某个<code>异步</code>请求的情况, 比如 <em>提交</em>/<em>确定</em> 等按钮.</p></blockquote><blockquote><p>但这种情况我们又需要处理一些并发的问题, 防止用户连续频繁的触发异步</p></blockquote><h3 id="其他方案-只列举几个"><a href="#其他方案-只列举几个" class="headerlink" title="其他方案 (只列举几个)"></a>其他方案 (只列举几个)</h3><ul><li><p>自己设置一个标志位, 来标识是否在请求中, 每次触发后对标志位判断</p><blockquote><p>缺点是需要额外设置标志位字段,重复性代码.降低代码可读性</p></blockquote></li><li><p>对点击触发的异步 进行 throttle 处理</p><blockquote><p>throttle设置的时间间隔是固定的, 没法估计请求实际使用的时间, 太短还是会连续触发. 太长体验很差</p></blockquote></li></ul><h3 id="我的方案-async-click-指令"><a href="#我的方案-async-click-指令" class="headerlink" title="我的方案 async-click 指令"></a>我的方案 async-click 指令</h3><ul><li>vue2:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">"async-click"</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 bind 的异步方案名称</span></span><br><span class="line">    <span class="keyword">const</span> fnName = binding.expression;</span><br><span class="line">    <span class="comment">// 获取具体方法的引用</span></span><br><span class="line">    <span class="keyword">const</span> fn = vnode.context &amp;&amp; vnode.context[fnName];</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"async-click 指令需要 binding 一个方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置内部的标志位</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="literal">false</span>;</span><br><span class="line">    el.addEventListener(</span><br><span class="line">      <span class="string">"click"</span>,</span><br><span class="line">      e =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对其他 click 时间阻止</span></span><br><span class="line">        e &amp;&amp; e.stopImmediatePropagation();</span><br><span class="line">        <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">          <span class="comment">// 第一次点</span></span><br><span class="line">          <span class="built_in">console</span>.debug(<span class="string">"click flag -&gt;"</span>, start);</span><br><span class="line">          start = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 执行,并获得返回值</span></span><br><span class="line">          <span class="keyword">const</span> rt = fn();</span><br><span class="line">          <span class="keyword">if</span> (!(rt <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">"async-click 指令绑定值错误:返回类型必须为 Promise"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.debug(rt);</span><br><span class="line">          <span class="comment">//! 此处需要特别注意, 必须是 Promise 完成, 不能再某种情况下永远处于 pending 状态</span></span><br><span class="line">          rt.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// promise 结束后重置标志位</span></span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">"finally"</span>);</span><br><span class="line">            start = <span class="literal">false</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>vue3<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.directive(<span class="string">"async-click"</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  created(el, binding) &#123;</span><br><span class="line">    <span class="comment">// 获取 bind 的异步方案名称</span></span><br><span class="line">    <span class="built_in">console</span>.debug(binding);</span><br><span class="line">    <span class="comment">// const fnName = binding;</span></span><br><span class="line">    <span class="comment">// 获取具体方法的引用</span></span><br><span class="line">    <span class="keyword">const</span> fn = binding.value</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"async-click 指令需要 binding 一个方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置内部的标志位</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="literal">false</span>;</span><br><span class="line">    el.addEventListener(</span><br><span class="line">      <span class="string">"click"</span>,</span><br><span class="line">      (e: MouseEvent) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对其他 click 时间阻止</span></span><br><span class="line">        e &amp;&amp; e.stopImmediatePropagation();</span><br><span class="line">        <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">          <span class="comment">// 第一次点</span></span><br><span class="line">          <span class="built_in">console</span>.debug(<span class="string">"click flag -&gt;"</span>, start);</span><br><span class="line">          start = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 执行,并获得返回值</span></span><br><span class="line">          <span class="keyword">const</span> rt: <span class="built_in">Promise</span>&lt;unknown&gt; = fn();</span><br><span class="line">          <span class="keyword">if</span> (!(rt <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">"async-click 指令绑定值错误:返回类型必须为 Promise"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.debug(rt);</span><br><span class="line">          <span class="comment">//! 此处需要特别注意, 必须是 Promise 完成, 不能再某种情况下永远处于 pending 状态</span></span><br><span class="line">          rt.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// promise 结束后重置标志位</span></span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">"finally"</span>);</span><br><span class="line">            start = <span class="literal">false</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>使用侧例子:</p><p>`将原来 @click=xxx 的部分替换为 v-async-click=xxx<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-async-click</span>=<span class="string">"demo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">round</span></span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">"pc-submit"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">       &gt;</span>提交<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line"> demo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">"demo start"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.info(<span class="string">"demo end"</span>);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未来可扩展部分"><a href="#未来可扩展部分" class="headerlink" title="未来可扩展部分:"></a>未来可扩展部分:</h3><ul><li>针对不同的事件</li><li>可以带入参数 fn(arg)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们经常遇到 &lt;code&gt;点击&lt;/code&gt; 按钮来触发某个&lt;code&gt;异步&lt;/code&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
      <category term="directive" scheme="https://dreambo8563.github.io/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>2020-2021年度总结</title>
    <link href="https://dreambo8563.github.io/2021/12/21/2020-2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://dreambo8563.github.io/2021/12/21/2020-2021年度总结/</id>
    <published>2021-12-21T04:39:43.000Z</published>
    <updated>2021-12-22T07:14:18.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寒冬-2020-2021"><a href="#寒冬-2020-2021" class="headerlink" title="寒冬 2020-2021"></a>寒冬 2020-2021</h2><blockquote><p>由于疫情,2020 的年度总结失约了,这次一并补齐</p></blockquote><h3 id="2020-年"><a href="#2020-年" class="headerlink" title="2020 年"></a>2020 年</h3><blockquote><p>之前 2019 重点比较偏向业务侧的参与和发展, 2020 多业务爆发</p></blockquote><ul><li>团队加入 code review, 形式上简化, 在 gitlab 上提 comments</li><li>团队进度全面上 Teambition, 任务进度可视化,颗粒细化. 推动产品侧内审</li><li>服务端容器化,全面上 k8s</li><li>团队看书,直播读书和vue3 文档讲解, 尝试直播撸代码</li><li>艰苦招聘的一年, 大力投入招聘工作</li><li>业务全面爆发,资源调动</li><li>前端优化 eslint 规则,应用于项目, 提高研发要求</li><li>对公共服务拆分剥离(共享数据,公用逻辑接口), 业务应用全面接入</li></ul><h3 id="2021-年"><a href="#2021-年" class="headerlink" title="2021 年"></a>2021 年</h3><blockquote><p>技术侧全面优化,架构演进 and “双减”</p></blockquote><ul><li><a href="https://dreambo8563.github.io/2021/05/21/FE-CDN/">前端 CDN 部署策略更新</a></li><li><a href="https://dreambo8563.github.io/2021/05/23/DDD%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE1/">DDD 实践</a></li><li>引入 golang 服务(预警服务/鉴权服务/原有公共逻辑迭代为 golang 语言)</li><li>引入 kafka(golang 的消息服务使用)</li><li>抽离独立服务(评语服务)</li><li>抽离公共数据读取服务 pizza(golang语言),尝试 clean code 代码结构</li><li>引入elasticsearch</li><li>创建 graphql 中间query 层服务(nodejs)</li><li><a href="https://dreambo8563.github.io/2021/06/18/sentry-trace/">tracing 能力增强</a></li><li><a href="https://dreambo8563.github.io/2021/05/30/%E6%9C%80%E8%BF%91%E4%B8%A4%E5%B9%B4%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">2020-2021架构演进</a></li><li>优化团队流程,设计文档UML图/ER图,技术评审,加入设计走查,提高项目体验</li><li>前端引入vuex, 部分项目使用 vue3</li><li>更新 watcher 包支持 vue3 (<a href="https://github.com/dreambo8563/next-vue-storage-watcher" target="_blank" rel="noopener">https://github.com/dreambo8563/next-vue-storage-watcher</a>)</li><li>更新 device 包支持 vue3 (<a href="https://github.com/dreambo8563/next-vue-storage-watcher" target="_blank" rel="noopener">https://github.com/dreambo8563/next-vue-storage-watcher</a>)</li><li>阅读一些设计模式</li><li>学习理财, 开始定投基金 :)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;寒冬-2020-2021&quot;&gt;&lt;a href=&quot;#寒冬-2020-2021&quot; class=&quot;headerlink&quot; title=&quot;寒冬 2020-2021&quot;&gt;&lt;/a&gt;寒冬 2020-2021&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于疫情,2020 的年度总结失约
      
    
    </summary>
    
      <category term="Thinking" scheme="https://dreambo8563.github.io/categories/Thinking/"/>
    
    
      <category term="Thinking" scheme="https://dreambo8563.github.io/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Composite</title>
    <link href="https://dreambo8563.github.io/2021/10/25/Design-Patterns-Composite/"/>
    <id>https://dreambo8563.github.io/2021/10/25/Design-Patterns-Composite/</id>
    <published>2021-10-25T09:16:59.000Z</published>
    <updated>2021-10-25T09:28:56.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Composite-Object-Tree"><a href="#Composite-Object-Tree" class="headerlink" title="Composite (Object Tree)"></a>Composite (Object Tree)</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/composite.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当需要构造一个类似树的结构</li><li>希望调用方对简单或者复杂的元素都能统一的调用</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>确认目标模型是一个可以拆分为递归组合的树结构. 必须包含 简单元素(没有子元素) 和 复杂组件(可以包含简单元素和其他复杂组件)</li><li>抽象出简单元素和 复杂组件的通用行为 interface</li><li>创建简单元素类</li><li>创建复杂组件类, 须有有一个数组类型字段, 来存储子元素, 且须有可以保存简单元素或者其他复杂组件类型. 实现 interface 的具体行为中,是循环调用的数组中元素的对应实现来计算的, 只是个代理, 自己并没有复杂逻辑</li><li>给复杂组件添加 增删改查操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Composite-Object-Tree&quot;&gt;&lt;a href=&quot;#Composite-Object-Tree&quot; class=&quot;headerlink&quot; title=&quot;Composite (Object Tree)&quot;&gt;&lt;/a&gt;Composite (Object Tre
      
    
    </summary>
    
      <category term="Structural" scheme="https://dreambo8563.github.io/categories/Structural/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Composite" scheme="https://dreambo8563.github.io/tags/Composite/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Bridge</title>
    <link href="https://dreambo8563.github.io/2021/10/21/Design-Patterns-Bridge/"/>
    <id>https://dreambo8563.github.io/2021/10/21/Design-Patterns-Bridge/</id>
    <published>2021-10-21T07:30:49.000Z</published>
    <updated>2021-10-21T07:43:42.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/bridge.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当有巨型的单个类有很多变种. 或者需要被重构拆分</li><li>当这个类有多个维度,方面,或者组件 会经常行的发生变化或者替换</li><li>如果你想在运行时切换不同的实现</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>先识别出类中的可以拆分的多个维度,方面或者组件</li><li>抽象出这些组件的 interface</li><li>根据不同的变种实现组件的interface</li><li>在被拆分类分配一个字段给某个抽象的组件实例, 在类型调用组件相关方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bridge&quot;&gt;&lt;a href=&quot;#Bridge&quot; class=&quot;headerlink&quot; title=&quot;Bridge&quot;&gt;&lt;/a&gt;Bridge&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dreambo856
      
    
    </summary>
    
      <category term="Structural" scheme="https://dreambo8563.github.io/categories/Structural/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Bridge" scheme="https://dreambo8563.github.io/tags/Bridge/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Adapter</title>
    <link href="https://dreambo8563.github.io/2021/10/20/Design-Patterns-Adapter/"/>
    <id>https://dreambo8563.github.io/2021/10/20/Design-Patterns-Adapter/</id>
    <published>2021-10-20T07:08:13.000Z</published>
    <updated>2021-10-27T03:50:22.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adapter-wrapper"><a href="#Adapter-wrapper" class="headerlink" title="Adapter (wrapper)"></a>Adapter (wrapper)</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/adapter.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>适合支持多继承的语言实现</li><li>当前逻辑需要调用一个遗留系统,或者不可变的第三方服务. 且第三方服务签名不能直接被当前逻辑使用. 类型不匹配</li><li>可以用 adapter 将不可变服务包裹起来, 并符合目标的 interface</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>找到至少 2 个接口不兼容的类,  1 个是不可变的服务类, 一个是调用方需要的参数类</li><li>抽象一个调用方需要的 interface , 行为包含所有使用到第三方服务的行为, 隐含的是 compsite 模式</li><li>创建 adapter 类</li><li>adapter 类加一个字段来保存第三方服务的实例</li><li>adapter 类 实现 interface 所有方法, 并在实现过程中,调用第三方服务, 对其兼容</li><li>调用方使用 adapter 实例, 在需要调用第三方的地方</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Adapter-wrapper&quot;&gt;&lt;a href=&quot;#Adapter-wrapper&quot; class=&quot;headerlink&quot; title=&quot;Adapter (wrapper)&quot;&gt;&lt;/a&gt;Adapter (wrapper)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="Structural" scheme="https://dreambo8563.github.io/categories/Structural/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Adapter" scheme="https://dreambo8563.github.io/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Singleton</title>
    <link href="https://dreambo8563.github.io/2021/10/15/Design-Patterns-Singleton/"/>
    <id>https://dreambo8563.github.io/2021/10/15/Design-Patterns-Singleton/</id>
    <published>2021-10-15T02:53:34.000Z</published>
    <updated>2021-10-20T07:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/singleton.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>需要全局同享对象,并加以控制</li><li>保证特定类只有一个实例</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>有一个私有字段来保存 单例实例</li><li>声明一个对外的方法获取实例</li><li>获取方法,需要 lazy, 并注意多线程的时候的加锁处理</li><li>隐藏构造函数或者其他创建行方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Singleton&quot;&gt;&lt;a href=&quot;#Singleton&quot; class=&quot;headerlink&quot; title=&quot;Singleton&quot;&gt;&lt;/a&gt;Singleton&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.co
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Singleton" scheme="https://dreambo8563.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Builder</title>
    <link href="https://dreambo8563.github.io/2021/10/14/Design-Patterns-Builder/"/>
    <id>https://dreambo8563.github.io/2021/10/14/Design-Patterns-Builder/</id>
    <published>2021-10-14T09:37:49.000Z</published>
    <updated>2021-10-14T09:47:03.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Builder-Director"><a href="#Builder-Director" class="headerlink" title="Builder/Director"></a>Builder/Director</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/builder.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当你需要<strong>构建一个比较复杂的对象</strong></li><li>这个对象的各种参数,在不同情况下都不相同, 并且都是可选参数</li><li>当有一套步骤是相同,但是具体实现不同的时候, 可以引入 director</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>定义 builder interface, 具体包含能配置的东西</li><li>创建 builder 实现类, 并且需要实现一个额外的 获取结果的方法, 因为不同 builder 实现类可以输出不同类型的结果, 所以不能定义在 interface 上</li><li>创建 director 类, 封装不同的 创建步骤套装</li><li>调用方 实例化 builder 和 director. 把 builder 实例传给 director. director 选择构造那种产物. 从 build 实例获取最终结果对象</li><li>如果大家创建产物的类型一致, 则可以直接在 director 里返回结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Builder-Director&quot;&gt;&lt;a href=&quot;#Builder-Director&quot; class=&quot;headerlink&quot; title=&quot;Builder/Director&quot;&gt;&lt;/a&gt;Builder/Director&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Builder" scheme="https://dreambo8563.github.io/tags/Builder/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Abstract-Factory</title>
    <link href="https://dreambo8563.github.io/2021/09/27/Design-Patterns-Abstract-Factory/"/>
    <id>https://dreambo8563.github.io/2021/09/27/Design-Patterns-Abstract-Factory/</id>
    <published>2021-09-27T14:20:05.000Z</published>
    <updated>2021-09-27T14:35:20.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract  Factory"></a>Abstract  Factory</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/Abstract%20Factory.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当你需要<strong>包含多种模型的变种组</strong>, 而且这些模型见是有关联性的, 所以产生的组</li><li>你不希望知道具体的模型是哪种类型, 只要用就是对应的那一组</li><li>当你有多个工厂方法在某个实体里的时候,考虑抽象工厂</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>将多个模型的 interface 抽象出来, 并实现对应的变种</li><li>抽象出 factory 的 interface, 包含不同模型的创建方法</li><li>对 factory interface 进行多组的实现, 产生 factory 接口的实现类, 实现类工厂中对应产生不同的变种</li><li>客户端代码 实例化 具体的工厂类, 并用哪个工厂类产生这一组的变种模型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abstract-Factory&quot;&gt;&lt;a href=&quot;#Abstract-Factory&quot; class=&quot;headerlink&quot; title=&quot;Abstract  Factory&quot;&gt;&lt;/a&gt;Abstract  Factory&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Factory" scheme="https://dreambo8563.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Factory-Method</title>
    <link href="https://dreambo8563.github.io/2021/09/14/Design-Patterns-Factory-Method/"/>
    <id>https://dreambo8563.github.io/2021/09/14/Design-Patterns-Factory-Method/</id>
    <published>2021-09-14T07:34:38.000Z</published>
    <updated>2021-09-14T07:59:18.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Factory-Mehtod"><a href="#Factory-Mehtod" class="headerlink" title="Factory Mehtod"></a>Factory Mehtod</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/design-factory-method.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>根据不同情况, 需要让后续逻辑使用到某个 Interface 下的不同变种(子类)</li><li>当前应用类, 对具体是哪个变种没有兴趣, 只要满足 Interface 即可</li><li>有少量的这种变种类,多的话可以演化为抽象工程模式</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>将应用类中获取变种实例的地方变为抽象方法, 应用类本身变为抽象类<blockquote><p>+createBtn() IBtn</p></blockquote></li><li>生成对应的 应用实现类, 实现createBtn, 返回对应的变种实例</li><li>在使用应用类实例的地方, 根据实际参数, 选择实例化具体的 某个应用实现类</li></ul><blockquote><p>简单使用的时候, 偷懒对应用类不做变化, 单纯当返回不同变种实例的逻辑封装在 createBtn(). 降低一些复杂度, 减少继承关系</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Factory-Mehtod&quot;&gt;&lt;a href=&quot;#Factory-Mehtod&quot; class=&quot;headerlink&quot; title=&quot;Factory Mehtod&quot;&gt;&lt;/a&gt;Factory Mehtod&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Factory" scheme="https://dreambo8563.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>sentry-trace</title>
    <link href="https://dreambo8563.github.io/2021/06/18/sentry-trace/"/>
    <id>https://dreambo8563.github.io/2021/06/18/sentry-trace/</id>
    <published>2021-06-17T16:48:43.000Z</published>
    <updated>2021-06-17T17:14:54.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h3><p>之前研究用jaeger 对程序进行侵入式的链路跟踪. 包括 http. grpc 协议的情况</p><h4 id="sentry"><a href="#sentry" class="headerlink" title="sentry"></a>sentry</h4><p>最近我们新搭建了新版本的sentry, 发现了之前没有的 feature -&gt; <strong>Performance</strong><br>从前端 Vue 到 PHP 的 Lavaral 到 内部的 GO 服务, 尝试了一下链路. 效果基本满足我们的需求.</p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/tracing1.png" alt=""></p><p>这里只是一个例子, 对 Vue 和 Lavaral 的支持比较好, 整合的时候基本没有入侵代码. 能够自动进行跟踪. 包括:</p><ul><li>前端静态资源</li><li>http 请求自动分拆</li><li>后端能够跟踪到具体 sql (Lavaral)</li></ul><p>缺点也有一些:</p><ul><li>SDK 不够完善. 后端继续向内部服务链路的时候可能需要改造中间件, 没有自动传送sentry-trace 头</li><li>接受上游的 trace 的时候可能需要看看源码, 文档不是很完善</li><li>很多语言框架无法自动采集链路, 需要自己在业务里写强侵入式的代码</li></ul><p>采集上来的数据能够阶段性比较:</p><blockquote><p>优化前性能指标</p></blockquote><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/tracing2.png" alt=""></p><blockquote><p>优化后</p></blockquote><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/tracing3.png" alt=""></p><p>这样能够很明显的看出近期的改动是否有作用.<br>同时能够协助发现能够优化的地方</p><ul><li>比如接口过多</li><li>静态资源过多, 或者过早引入</li><li>接口没有并行触发</li><li>慢 sql 等</li></ul><h4 id="给-Sentry-点赞"><a href="#给-Sentry-点赞" class="headerlink" title="给 Sentry 点赞"></a>给 Sentry 点赞</h4><ul><li>保持了错误捕获相关的能力</li><li>增强了 Tracing 和 Logging 的能力<br>对一般的可观测性都能满足需求了, 而且覆盖了前后端, 不同语言和框架. 反正大不了就是自己看源码, 或者自己实现点逻辑, 已经很不错了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链路跟踪&quot;&gt;&lt;a href=&quot;#链路跟踪&quot; class=&quot;headerlink&quot; title=&quot;链路跟踪&quot;&gt;&lt;/a&gt;链路跟踪&lt;/h3&gt;&lt;p&gt;之前研究用jaeger 对程序进行侵入式的链路跟踪. 包括 http. grpc 协议的情况&lt;/p&gt;
&lt;h4 id=&quot;sen
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="Sentry" scheme="https://dreambo8563.github.io/tags/Sentry/"/>
    
      <category term="Tracing" scheme="https://dreambo8563.github.io/tags/Tracing/"/>
    
  </entry>
  
  <entry>
    <title>最近两年的架构演进</title>
    <link href="https://dreambo8563.github.io/2021/05/30/%E6%9C%80%E8%BF%91%E4%B8%A4%E5%B9%B4%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
    <id>https://dreambo8563.github.io/2021/05/30/最近两年的架构演进/</id>
    <published>2021-05-30T15:38:53.000Z</published>
    <updated>2021-05-30T15:47:13.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间"><a href="#最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间" class="headerlink" title="最近两年由于前后端都负责, 就给与了很大的架构锻炼的机会和空间"></a>最近两年由于前后端都负责, 就给与了很大的架构锻炼的机会和空间</h3><h5 id="Stage1"><a href="#Stage1" class="headerlink" title="Stage1"></a>Stage1</h5><ul><li>原始阶段</li><li>实体机直接部署</li><li>手动发布打包</li></ul><h5 id="Stage2"><a href="#Stage2" class="headerlink" title="Stage2"></a>Stage2</h5><ul><li>前端jenkins</li><li>前端全量部署 CDN/OSS</li><li>全栈 https</li></ul><h5 id="Stage3"><a href="#Stage3" class="headerlink" title="Stage3"></a>Stage3</h5><ul><li>后端容器化部署</li><li>后端 CD 自动化</li><li>增加伸缩性和自我恢复能力</li></ul><h5 id="Stage4"><a href="#Stage4" class="headerlink" title="Stage4"></a>Stage4</h5><ul><li>前端部署容器化</li><li>后端服务拆分,实践 DDD</li><li>客户端机制隐藏后端服务实现,版本化升级</li><li>引入 ES 的使用</li><li>部分Go 服务实践</li><li>区分业务数据和通用静态数据</li><li>引入 Graphql, 提高开发效率</li><li>接入 kafka</li></ul><h4 id="全景路线图"><a href="#全景路线图" class="headerlink" title="全景路线图"></a>全景路线图</h4><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/Evolution.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间&quot;&gt;&lt;a href=&quot;#最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间&quot; class=&quot;headerlink&quot; title=&quot;最近两年由于前后端都负责, 就给与了很大的架构锻炼的机会和空间&quot;
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>DDD实践项目1</title>
    <link href="https://dreambo8563.github.io/2021/05/23/DDD%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE1/"/>
    <id>https://dreambo8563.github.io/2021/05/23/DDD实践项目1/</id>
    <published>2021-05-23T15:34:14.000Z</published>
    <updated>2021-05-23T15:43:52.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="之前读了一些DDD相关的数据-也在一个项目上实践了一下"><a href="#之前读了一些DDD相关的数据-也在一个项目上实践了一下" class="headerlink" title="之前读了一些DDD相关的数据, 也在一个项目上实践了一下"></a>之前读了一些DDD相关的数据, 也在一个项目上实践了一下</h3><h4 id="理由"><a href="#理由" class="headerlink" title="理由"></a>理由</h4><ul><li>后台项目大部分不具有技术上的挑战</li><li>基于 k8s, 云等技术的普及. 横向扩展伸缩, 稳定性等基础架构变得普及和容易解决</li><li>难点聚焦于业务复杂度, 业务架构的设计上</li></ul><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/ddd1.png" alt=""></p><ul><li>内层是核心业务模型(粉色+绿色)</li><li>领域服务/独立模块(黄色)</li><li>外层是基础设施(可替换)<blockquote><p>外部服务 可以 用 DI 方式 注入到 核心逻辑中(做个抽象 - 门面模式), 核心业务逻辑无需关心服务的具体实现</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/ddd1-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;之前读了一些DDD相关的数据-也在一个项目上实践了一下&quot;&gt;&lt;a href=&quot;#之前读了一些DDD相关的数据-也在一个项目上实践了一下&quot; class=&quot;headerlink&quot; title=&quot;之前读了一些DDD相关的数据, 也在一个项目上实践了一下&quot;&gt;&lt;/a&gt;之前读了
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="DDD" scheme="https://dreambo8563.github.io/tags/DDD/"/>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>FE-CDN</title>
    <link href="https://dreambo8563.github.io/2021/05/21/FE-CDN/"/>
    <id>https://dreambo8563.github.io/2021/05/21/FE-CDN/</id>
    <published>2021-05-21T08:59:37.000Z</published>
    <updated>2021-05-21T10:20:36.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣"><a href="#最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣" class="headerlink" title="最近把项目的前端部署策略优化了下,顺手对比了几种方式的优劣"></a>最近把项目的前端部署策略优化了下,顺手对比了几种方式的优劣</h1><h3 id="策略-1"><a href="#策略-1" class="headerlink" title="策略 1"></a>策略 1</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/cdn1.png" alt=""></p><ul><li>打包产物全量推送 OSS</li><li>CDN 域名回源 OSS (阿里业务)</li><li>前端跨域访问后端 api 服务</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>依托阿里云</li><li>不需要前端用的 web 服务</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>CDN 缓存问题需要处理</li><li>需要通过 CDN 上正则模拟 history 模式, 返回 index.html</li><li>跨域 Option 请求</li></ul><hr><hr><h3 id="策略-2"><a href="#策略-2" class="headerlink" title="策略 2"></a>策略 2</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/cdn2.png" alt=""></p><ul><li>打包产物(非 index.htm)推送 OSS</li><li>公用CDN 域名回源 OSS (阿里业务)</li><li>用户访问自己的 nginx 服务(index.html)</li><li>index.html 上利用 script 标签调用 cdn 上的 js/css等静态资源</li><li>nginx 反向代理访问 api</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>绝大部分静态利用 CDN 资源</li><li>自己控制缓存,增强可编程能力</li><li>不跨域</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>打包配置需要独立处理</li><li>需要自己的 web 服务</li></ul><hr><hr><h3 id="策略-3"><a href="#策略-3" class="headerlink" title="策略 3"></a>策略 3</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/cdn3.png" alt=""></p><ul><li>打包产物放自己 nginx</li><li>公用CDN域名回源自己的 web服务</li><li>用户访问CDN</li><li>nginx 反向代理访问 api</li></ul><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>利用 CDN 能力</li><li>自己控制缓存,增强可编程能力</li><li>不跨域</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>CDN 缓存问题</li><li>回源还是会占用自己的流量带宽</li><li>需要自己的 web 服务</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣&quot;&gt;&lt;a href=&quot;#最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣&quot; class=&quot;headerlink&quot; title=&quot;最近把项目的前端部署策略优化了下,顺手对比了几种方式的优劣&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="FE" scheme="https://dreambo8563.github.io/categories/FE/"/>
    
    
      <category term="CDN" scheme="https://dreambo8563.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>JS波浪符巧用</title>
    <link href="https://dreambo8563.github.io/2020/07/03/JS%E6%B3%A2%E6%B5%AA%E7%AC%A6%E5%B7%A7%E7%94%A8/"/>
    <id>https://dreambo8563.github.io/2020/07/03/JS波浪符巧用/</id>
    <published>2020-07-03T15:00:37.000Z</published>
    <updated>2020-07-03T15:08:15.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>原文地址: <a href="https://khalilstemmler.com/articles/tilde-in-javascript/" target="_blank" rel="noopener">https://khalilstemmler.com/articles/tilde-in-javascript/</a></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>源于一段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(~followers.indexOf(target)) &#123;</span><br><span class="line">  <span class="comment">// do some action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深挖"><a href="#深挖" class="headerlink" title="深挖"></a>深挖</h2><p>~A 同等于 -(A + 1)</p><h2 id="和-JS-的联系"><a href="#和-JS-的联系" class="headerlink" title="和 JS 的联系"></a>和 JS 的联系</h2><blockquote><p>The indexOf() method returns the first index at which a given element can be found in the array, or -1 if it is not present.</p></blockquote><blockquote><p>The indexOf() method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.</p></blockquote><p>只有当 A=-1 的时候 ~A === 0 </p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>不用去和 -1 比了!!!<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!!~fruits.indexOf(<span class="string">'apples'</span>)) &#123;</span><br><span class="line">  <span class="comment">// Yay apples</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Found apples!"</span>) <span class="comment">// &lt;= this will print</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Still no apples</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"No apples apparently"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;原文地址: &lt;a href=&quot;https://khalilstemmler.com/articles/tilde-in-javascript
      
    
    </summary>
    
      <category term="JS" scheme="https://dreambo8563.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://dreambo8563.github.io/tags/JS/"/>
    
  </entry>
  
</feed>
