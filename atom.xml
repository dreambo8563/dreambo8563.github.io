<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Vincent&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dreambo8563.github.io/"/>
  <updated>2022-04-15T09:36:06.644Z</updated>
  <id>https://dreambo8563.github.io/</id>
  
  <author>
    <name>Vincent Guo</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Vue-Mixin-RenderTrack</title>
    <link href="https://dreambo8563.github.io/2022/04/15/Vue-Mixin-RenderTrack/"/>
    <id>https://dreambo8563.github.io/2022/04/15/Vue-Mixin-RenderTrack/</id>
    <published>2022-04-15T08:04:13.000Z</published>
    <updated>2022-04-15T09:36:06.644Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li>开始使用 vue 3.x 开发项目, 并使用 pinia 等相关新的生态 并阅读相关文档</li><li>希望基于 vue 3 写点代码, 用了 新的 dev_tools, 功能丰富了很多. </li><li>最近几个项目里都遇到了不同情况下的性能问题</li></ul><h3 id="RenderTracker-的作用"><a href="#RenderTracker-的作用" class="headerlink" title="RenderTracker 的作用"></a>RenderTracker 的作用</h3><p>vue 3 生命周期 onRenderTriggered 文档</p><blockquote><p>Registers a debug hook to be called when a reactive dependency triggers the component’s render effect to be re-run. 是一个 debug 模式下的 hook, 会因为响应式的依赖触发组件的重新渲染</p></blockquote><p><a href="https://vuejs.org/api/composition-api-lifecycle.html#onrendertriggered" target="_blank" rel="noopener">https://vuejs.org/api/composition-api-lifecycle.html#onrendertriggered</a></p><p>综合文档看, 这个 hook 比较适合查看是否某些组件过多的频繁渲染, 并给出一些简单的信息协助定位问题</p><h3 id="小问题"><a href="#小问题" class="headerlink" title="小问题"></a>小问题</h3><p>因为这个工具的注入是针对所有的组件为目标的</p><p><strong>但是:</strong> vue 3.x 本身似乎没有提供, 也不提倡这种全局的无差别注入, 特别是咱们还行注入到 hook 中让它自动执行</p><blockquote><p>In Vue 2, mixins were the primary mechanism for creating reusable chunks of component logic. While mixins continue to be supported in Vue 3, Composition API is now the preferred approach for code reuse between components.</p></blockquote><p>从某些方面看, vue 3.x 并没有完全覆盖 vue 2.x 的所有能力. 比如 <a href="https://vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance" target="_blank" rel="noopener">https://vuejs.org/guide/components/attrs.html#disabling-attribute-inheritance</a></p><p>所有这个小工具使用 options 的写法来注入还是可以理解的</p><h3 id="工具说明"><a href="#工具说明" class="headerlink" title="工具说明"></a>工具说明</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/b83a75ae9a588cf71ebc43605128fdab51579dba/renderTrack.png" alt=""></p><p>输出信息包含 3 种组件分类:</p><ul><li><p>路由组件</p><blockquote><p>可以输出当时的路由信息</p></blockquote></li><li><p>具名组件 (可以获取名字的,一般来说 组件库的都是有名字的)</p><blockquote><p>图中未包含,只是显示名字,只需要看哪些是否触发非常频繁就足够了</p></blockquote></li><li><p>无名组件 (一般都是业务自己写的)</p><blockquote><p>会输出 操作类型 / key / value , 并可以展开 trace 信息协助定位到具体代码位置</p></blockquote></li></ul><h3 id="工具实现"><a href="#工具实现" class="headerlink" title="工具实现"></a>工具实现</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  defineComponent,</span><br><span class="line">  <span class="keyword">type</span> ComponentPublicInstance,</span><br><span class="line">  <span class="keyword">type</span> DebuggerEvent,</span><br><span class="line">  <span class="keyword">type</span> Ref,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">"vue"</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; RouteLocationNormalizedLoaded &#125; <span class="keyword">from</span> <span class="string">"vue-router"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置参数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> RenderTrackOptions &#123;</span><br><span class="line">  exclusive: RenderTrackKind[];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 组件类型</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">enum</span> RenderTrackKind &#123;</span><br><span class="line">  Router, <span class="comment">// 路由组件</span></span><br><span class="line">  NamedComponent, <span class="comment">// 具名组件</span></span><br><span class="line">  UnnamedComponent, <span class="comment">// 无名组件</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> style = [</span><br><span class="line">  <span class="string">"background: greenyellow"</span>,</span><br><span class="line">  <span class="string">"color: gray"</span>,</span><br><span class="line">  <span class="string">"padding: 3px 5px"</span>,</span><br><span class="line">  <span class="string">"border-radius:10px"</span>,</span><br><span class="line">].join(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> pageStyle = [</span><br><span class="line">  <span class="string">"background: gold"</span>,</span><br><span class="line">  <span class="string">"color: gray"</span>,</span><br><span class="line">  <span class="string">"padding: 3px 5px"</span>,</span><br><span class="line">  <span class="string">"border-radius:10px"</span>,</span><br><span class="line">].join(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routerStyle = [</span><br><span class="line">  <span class="string">"background: #ef94ff"</span>,</span><br><span class="line">  <span class="string">"color: gray"</span>,</span><br><span class="line">  <span class="string">"padding: 3px 5px"</span>,</span><br><span class="line">  <span class="string">"border-radius:10px"</span>,</span><br><span class="line">].join(<span class="string">";"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (</span><br><span class="line">  options: RenderTrackOptions = &#123;</span><br><span class="line">    exclusive: [],</span><br><span class="line">  &#125;</span><br><span class="line">) =&gt;</span><br><span class="line">  defineComponent(&#123;</span><br><span class="line">    renderTriggered(e: DebuggerEvent) &#123;</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        options.exclusive.length ==</span><br><span class="line">        [</span><br><span class="line">          RenderTrackKind.NamedComponent,</span><br><span class="line">          RenderTrackKind.Router,</span><br><span class="line">          RenderTrackKind.UnnamedComponent,</span><br><span class="line">        ].length</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// 如果所有类型都被排除, 则无需执行</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      [runUnnamedComponent, runRoute, runNamedComponent].forEach(<span class="function">(<span class="params">fn</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (fn(options, <span class="keyword">this</span>, e)) &#123;</span><br><span class="line">          <span class="comment">// 有一个匹配的就中断</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据 trace 路径获取到文件名</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; [filePath]</span></span><br><span class="line"><span class="comment"> * @returns &#123;string&#125; 文件名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractFileName</span>(<span class="params">filePath?: <span class="built_in">string</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> p = filePath || <span class="string">""</span>;</span><br><span class="line">  <span class="keyword">const</span> arr = p.split(<span class="string">"/"</span>);</span><br><span class="line">  <span class="keyword">return</span> arr[arr.length - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runRoute</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RenderTrackOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentComponent: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  e: DebuggerEvent</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件名字</span></span><br><span class="line">  <span class="keyword">let</span> name =</span><br><span class="line">    currentComponent.$options.name || currentComponent.$options._componentTag;</span><br><span class="line">  <span class="comment">// 判断是否是路由, 或者用 (e.target as Ref&lt;RouteLocationNormalizedLoaded&gt;)?.value?.fullPath 来判断</span></span><br><span class="line">  <span class="keyword">const</span> isRouter = name == <span class="string">"RouterView"</span>;</span><br><span class="line">  <span class="keyword">const</span> hasPermission = !options.exclusive.includes(RenderTrackKind.Router);</span><br><span class="line">  <span class="keyword">if</span> (isRouter &amp;&amp; hasPermission) &#123;</span><br><span class="line">    <span class="comment">// 输出路由组件信息</span></span><br><span class="line">    <span class="keyword">const</span> route = (e.target <span class="keyword">as</span> Ref&lt;RouteLocationNormalizedLoaded&gt;).value;</span><br><span class="line">    name = <span class="string">`Router: <span class="subst">$&#123;route.fullPath || route.path&#125;</span>`</span>;</span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(</span><br><span class="line">      <span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f6b4</span>)&#125;</span> <span class="subst">$&#123;name&#125;</span> `</span>,</span><br><span class="line">      routerStyle</span><br><span class="line">    );</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f308</span>)&#125;</span> Route`</span>, route);</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runNamedComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RenderTrackOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentComponent: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  _: DebuggerEvent</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件名字</span></span><br><span class="line">  <span class="keyword">const</span> name =</span><br><span class="line">    currentComponent.$options.name || currentComponent.$options._componentTag;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> hasPermission = !options.exclusive.includes(</span><br><span class="line">    RenderTrackKind.NamedComponent</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name &amp;&amp; hasPermission) &#123;</span><br><span class="line">    <span class="comment">// 输出具名组件信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f6b4</span>)&#125;</span> <span class="subst">$&#123;name&#125;</span> `</span>, style);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runUnnamedComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  options: RenderTrackOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentComponent: ComponentPublicInstance,</span></span></span><br><span class="line"><span class="function"><span class="params">  e: DebuggerEvent</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">boolean</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获取组件名字</span></span><br><span class="line">  <span class="keyword">const</span> name =</span><br><span class="line">    currentComponent.$options.name || currentComponent.$options._componentTag;</span><br><span class="line">  <span class="keyword">const</span> hasPermission = !options.exclusive.includes(</span><br><span class="line">    RenderTrackKind.UnnamedComponent</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!name &amp;&amp; hasPermission) &#123;</span><br><span class="line">    <span class="comment">// 输出无名组件信息</span></span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(</span><br><span class="line">      <span class="string">`%c <span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f6b4</span>)&#125;</span> <span class="subst">$&#123;extractFileName(</span></span></span><br><span class="line"><span class="string"><span class="subst">        currentComponent.$options.__file</span></span></span><br><span class="line"><span class="string"><span class="subst">      )&#125;</span>`</span>,</span><br><span class="line">      pageStyle</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f91c</span>)&#125;</span> <span class="subst">$&#123;e.<span class="keyword">type</span>.toUpperCase()&#125;</span> [<span class="subst">$&#123;e.key&#125;</span>] `</span>,</span><br><span class="line">      e.newValue || (e.target <span class="keyword">as</span> Ref&lt;unknown&gt;).value</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.groupCollapsed(<span class="string">`<span class="subst">$&#123;<span class="built_in">String</span>.fromCodePoint(<span class="number">0x1f308</span>)&#125;</span> Trace`</span>);</span><br><span class="line">    <span class="built_in">console</span>.trace(<span class="string">""</span>);</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="built_in">console</span>.groupEnd();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注入使用"><a href="#注入使用" class="headerlink" title="注入使用"></a>注入使用</h3><figure class="highlight ts"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排除具名(大部分是组件库)组件的信息, 默认是都不排除</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.meta.env.DEV) &#123;</span><br><span class="line">  app.mixin(</span><br><span class="line">    renderTrack(&#123;</span><br><span class="line">      exclusive: [RenderTrackKind.NamedComponent],</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全部输出</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">import</span>.meta.env.DEV) &#123;</span><br><span class="line">  app.mixin(</span><br><span class="line">    renderTrack()</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;开始使用 vue 3.x 开发项目, 并使用 pinia 等相关新的生态 并阅读相关文档&lt;/li&gt;
&lt;li&gt;希望基于 vue 3
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
      <category term="mixin" scheme="https://dreambo8563.github.io/tags/mixin/"/>
    
  </entry>
  
  <entry>
    <title>vue-async-click</title>
    <link href="https://dreambo8563.github.io/2022/03/31/vue-async-click/"/>
    <id>https://dreambo8563.github.io/2022/03/31/vue-async-click/</id>
    <published>2022-03-31T07:00:13.000Z</published>
    <updated>2022-03-31T08:11:14.515Z</updated>
    
    <content type="html"><![CDATA[<h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><blockquote><p>我们经常遇到 <code>点击</code> 按钮来触发某个<code>异步</code>请求的情况, 比如 <em>提交</em>/<em>确定</em> 等按钮.</p></blockquote><blockquote><p>但这种情况我们又需要处理一些并发的问题, 防止用户连续频繁的触发异步</p></blockquote><h3 id="其他方案-只列举几个"><a href="#其他方案-只列举几个" class="headerlink" title="其他方案 (只列举几个)"></a>其他方案 (只列举几个)</h3><ul><li><p>自己设置一个标志位, 来标识是否在请求中, 每次触发后对标志位判断</p><blockquote><p>缺点是需要额外设置标志位字段,重复性代码.降低代码可读性</p></blockquote></li><li><p>对点击触发的异步 进行 throttle 处理</p><blockquote><p>throttle设置的时间间隔是固定的, 没法估计请求实际使用的时间, 太短还是会连续触发. 太长体验很差</p></blockquote></li></ul><h3 id="我的方案-async-click-指令"><a href="#我的方案-async-click-指令" class="headerlink" title="我的方案 async-click 指令"></a>我的方案 async-click 指令</h3><ul><li>vue2:</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Vue.directive(<span class="string">"async-click"</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  bind: <span class="function"><span class="keyword">function</span> (<span class="params">el, binding, vnode</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取 bind 的异步方案名称</span></span><br><span class="line">    <span class="keyword">const</span> fnName = binding.expression;</span><br><span class="line">    <span class="comment">// 获取具体方法的引用</span></span><br><span class="line">    <span class="keyword">const</span> fn = vnode.context &amp;&amp; vnode.context[fnName];</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"async-click 指令需要 binding 一个方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置内部的标志位</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="literal">false</span>;</span><br><span class="line">    el.addEventListener(</span><br><span class="line">      <span class="string">"click"</span>,</span><br><span class="line">      e =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对其他 click 时间阻止</span></span><br><span class="line">        e &amp;&amp; e.stopImmediatePropagation();</span><br><span class="line">        <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">          <span class="comment">// 第一次点</span></span><br><span class="line">          <span class="built_in">console</span>.debug(<span class="string">"click flag -&gt;"</span>, start);</span><br><span class="line">          start = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 执行,并获得返回值</span></span><br><span class="line">          <span class="keyword">const</span> rt = fn();</span><br><span class="line">          <span class="keyword">if</span> (!(rt <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">"async-click 指令绑定值错误:返回类型必须为 Promise"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.debug(rt);</span><br><span class="line">          <span class="comment">//! 此处需要特别注意, 必须是 Promise 完成, 不能再某种情况下永远处于 pending 状态</span></span><br><span class="line">          rt.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// promise 结束后重置标志位</span></span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">"finally"</span>);</span><br><span class="line">            start = <span class="literal">false</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>vue3<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.directive(<span class="string">"async-click"</span>, &#123;</span><br><span class="line">  <span class="comment">// 当被绑定的元素插入到 DOM 中时……</span></span><br><span class="line">  created(el, binding) &#123;</span><br><span class="line">    <span class="comment">// 获取 bind 的异步方案名称</span></span><br><span class="line">    <span class="built_in">console</span>.debug(binding);</span><br><span class="line">    <span class="comment">// const fnName = binding;</span></span><br><span class="line">    <span class="comment">// 获取具体方法的引用</span></span><br><span class="line">    <span class="keyword">const</span> fn = binding.value</span><br><span class="line">    <span class="keyword">if</span> (!fn) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"async-click 指令需要 binding 一个方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置内部的标志位</span></span><br><span class="line">    <span class="keyword">let</span> start = <span class="literal">false</span>;</span><br><span class="line">    el.addEventListener(</span><br><span class="line">      <span class="string">"click"</span>,</span><br><span class="line">      (e: MouseEvent) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 对其他 click 时间阻止</span></span><br><span class="line">        e &amp;&amp; e.stopImmediatePropagation();</span><br><span class="line">        <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">          <span class="comment">// 第一次点</span></span><br><span class="line">          <span class="built_in">console</span>.debug(<span class="string">"click flag -&gt;"</span>, start);</span><br><span class="line">          start = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 执行,并获得返回值</span></span><br><span class="line">          <span class="keyword">const</span> rt: <span class="built_in">Promise</span>&lt;unknown&gt; = fn();</span><br><span class="line">          <span class="keyword">if</span> (!(rt <span class="keyword">instanceof</span> <span class="built_in">Promise</span>)) &#123;</span><br><span class="line">            <span class="built_in">console</span>.error(<span class="string">"async-click 指令绑定值错误:返回类型必须为 Promise"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">console</span>.debug(rt);</span><br><span class="line">          <span class="comment">//! 此处需要特别注意, 必须是 Promise 完成, 不能再某种情况下永远处于 pending 状态</span></span><br><span class="line">          rt.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// promise 结束后重置标志位</span></span><br><span class="line">            <span class="built_in">console</span>.debug(<span class="string">"finally"</span>);</span><br><span class="line">            start = <span class="literal">false</span>;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="literal">true</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><p>使用侧例子:</p><p>`将原来 @click=xxx 的部分替换为 v-async-click=xxx<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">van-button</span></span></span><br><span class="line"><span class="tag">       <span class="attr">v-async-click</span>=<span class="string">"demo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">round</span></span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">"pc-submit"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">"primary"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">size</span>=<span class="string">"normal"</span></span></span><br><span class="line"><span class="tag">       &gt;</span>提交<span class="tag">&lt;/<span class="name">van-button</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line"> demo() &#123;</span><br><span class="line">      <span class="built_in">console</span>.info(<span class="string">"demo start"</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">        setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.info(<span class="string">"demo end"</span>);</span><br><span class="line">          resolve();</span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="未来可扩展部分"><a href="#未来可扩展部分" class="headerlink" title="未来可扩展部分:"></a>未来可扩展部分:</h3><ul><li>针对不同的事件</li><li>可以带入参数 fn(arg)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;解决的问题&quot;&gt;&lt;a href=&quot;#解决的问题&quot; class=&quot;headerlink&quot; title=&quot;解决的问题&quot;&gt;&lt;/a&gt;解决的问题&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;我们经常遇到 &lt;code&gt;点击&lt;/code&gt; 按钮来触发某个&lt;code&gt;异步&lt;/code&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
      <category term="directive" scheme="https://dreambo8563.github.io/tags/directive/"/>
    
  </entry>
  
  <entry>
    <title>2020-2021年度总结</title>
    <link href="https://dreambo8563.github.io/2021/12/21/2020-2021%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/"/>
    <id>https://dreambo8563.github.io/2021/12/21/2020-2021年度总结/</id>
    <published>2021-12-21T04:39:43.000Z</published>
    <updated>2021-12-22T07:14:18.310Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寒冬-2020-2021"><a href="#寒冬-2020-2021" class="headerlink" title="寒冬 2020-2021"></a>寒冬 2020-2021</h2><blockquote><p>由于疫情,2020 的年度总结失约了,这次一并补齐</p></blockquote><h3 id="2020-年"><a href="#2020-年" class="headerlink" title="2020 年"></a>2020 年</h3><blockquote><p>之前 2019 重点比较偏向业务侧的参与和发展, 2020 多业务爆发</p></blockquote><ul><li>团队加入 code review, 形式上简化, 在 gitlab 上提 comments</li><li>团队进度全面上 Teambition, 任务进度可视化,颗粒细化. 推动产品侧内审</li><li>服务端容器化,全面上 k8s</li><li>团队看书,直播读书和vue3 文档讲解, 尝试直播撸代码</li><li>艰苦招聘的一年, 大力投入招聘工作</li><li>业务全面爆发,资源调动</li><li>前端优化 eslint 规则,应用于项目, 提高研发要求</li><li>对公共服务拆分剥离(共享数据,公用逻辑接口), 业务应用全面接入</li></ul><h3 id="2021-年"><a href="#2021-年" class="headerlink" title="2021 年"></a>2021 年</h3><blockquote><p>技术侧全面优化,架构演进 and “双减”</p></blockquote><ul><li><a href="https://dreambo8563.github.io/2021/05/21/FE-CDN/">前端 CDN 部署策略更新</a></li><li><a href="https://dreambo8563.github.io/2021/05/23/DDD%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE1/">DDD 实践</a></li><li>引入 golang 服务(预警服务/鉴权服务/原有公共逻辑迭代为 golang 语言)</li><li>引入 kafka(golang 的消息服务使用)</li><li>抽离独立服务(评语服务)</li><li>抽离公共数据读取服务 pizza(golang语言),尝试 clean code 代码结构</li><li>引入elasticsearch</li><li>创建 graphql 中间query 层服务(nodejs)</li><li><a href="https://dreambo8563.github.io/2021/06/18/sentry-trace/">tracing 能力增强</a></li><li><a href="https://dreambo8563.github.io/2021/05/30/%E6%9C%80%E8%BF%91%E4%B8%A4%E5%B9%B4%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/">2020-2021架构演进</a></li><li>优化团队流程,设计文档UML图/ER图,技术评审,加入设计走查,提高项目体验</li><li>前端引入vuex, 部分项目使用 vue3</li><li>更新 watcher 包支持 vue3 (<a href="https://github.com/dreambo8563/next-vue-storage-watcher" target="_blank" rel="noopener">https://github.com/dreambo8563/next-vue-storage-watcher</a>)</li><li>更新 device 包支持 vue3 (<a href="https://github.com/dreambo8563/next-vue-storage-watcher" target="_blank" rel="noopener">https://github.com/dreambo8563/next-vue-storage-watcher</a>)</li><li>阅读一些设计模式</li><li>学习理财, 开始定投基金 :)</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;寒冬-2020-2021&quot;&gt;&lt;a href=&quot;#寒冬-2020-2021&quot; class=&quot;headerlink&quot; title=&quot;寒冬 2020-2021&quot;&gt;&lt;/a&gt;寒冬 2020-2021&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;由于疫情,2020 的年度总结失约
      
    
    </summary>
    
      <category term="Thinking" scheme="https://dreambo8563.github.io/categories/Thinking/"/>
    
    
      <category term="Thinking" scheme="https://dreambo8563.github.io/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Composite</title>
    <link href="https://dreambo8563.github.io/2021/10/25/Design-Patterns-Composite/"/>
    <id>https://dreambo8563.github.io/2021/10/25/Design-Patterns-Composite/</id>
    <published>2021-10-25T09:16:59.000Z</published>
    <updated>2021-10-25T09:28:56.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Composite-Object-Tree"><a href="#Composite-Object-Tree" class="headerlink" title="Composite (Object Tree)"></a>Composite (Object Tree)</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/composite.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当需要构造一个类似树的结构</li><li>希望调用方对简单或者复杂的元素都能统一的调用</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>确认目标模型是一个可以拆分为递归组合的树结构. 必须包含 简单元素(没有子元素) 和 复杂组件(可以包含简单元素和其他复杂组件)</li><li>抽象出简单元素和 复杂组件的通用行为 interface</li><li>创建简单元素类</li><li>创建复杂组件类, 须有有一个数组类型字段, 来存储子元素, 且须有可以保存简单元素或者其他复杂组件类型. 实现 interface 的具体行为中,是循环调用的数组中元素的对应实现来计算的, 只是个代理, 自己并没有复杂逻辑</li><li>给复杂组件添加 增删改查操作</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Composite-Object-Tree&quot;&gt;&lt;a href=&quot;#Composite-Object-Tree&quot; class=&quot;headerlink&quot; title=&quot;Composite (Object Tree)&quot;&gt;&lt;/a&gt;Composite (Object Tre
      
    
    </summary>
    
      <category term="Structural" scheme="https://dreambo8563.github.io/categories/Structural/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Composite" scheme="https://dreambo8563.github.io/tags/Composite/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Bridge</title>
    <link href="https://dreambo8563.github.io/2021/10/21/Design-Patterns-Bridge/"/>
    <id>https://dreambo8563.github.io/2021/10/21/Design-Patterns-Bridge/</id>
    <published>2021-10-21T07:30:49.000Z</published>
    <updated>2021-10-21T07:43:42.650Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/bridge.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当有巨型的单个类有很多变种. 或者需要被重构拆分</li><li>当这个类有多个维度,方面,或者组件 会经常行的发生变化或者替换</li><li>如果你想在运行时切换不同的实现</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>先识别出类中的可以拆分的多个维度,方面或者组件</li><li>抽象出这些组件的 interface</li><li>根据不同的变种实现组件的interface</li><li>在被拆分类分配一个字段给某个抽象的组件实例, 在类型调用组件相关方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Bridge&quot;&gt;&lt;a href=&quot;#Bridge&quot; class=&quot;headerlink&quot; title=&quot;Bridge&quot;&gt;&lt;/a&gt;Bridge&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/dreambo856
      
    
    </summary>
    
      <category term="Structural" scheme="https://dreambo8563.github.io/categories/Structural/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Bridge" scheme="https://dreambo8563.github.io/tags/Bridge/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Adapter</title>
    <link href="https://dreambo8563.github.io/2021/10/20/Design-Patterns-Adapter/"/>
    <id>https://dreambo8563.github.io/2021/10/20/Design-Patterns-Adapter/</id>
    <published>2021-10-20T07:08:13.000Z</published>
    <updated>2021-10-27T03:50:22.807Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Adapter-wrapper"><a href="#Adapter-wrapper" class="headerlink" title="Adapter (wrapper)"></a>Adapter (wrapper)</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/adapter.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>适合支持多继承的语言实现</li><li>当前逻辑需要调用一个遗留系统,或者不可变的第三方服务. 且第三方服务签名不能直接被当前逻辑使用. 类型不匹配</li><li>可以用 adapter 将不可变服务包裹起来, 并符合目标的 interface</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>找到至少 2 个接口不兼容的类,  1 个是不可变的服务类, 一个是调用方需要的参数类</li><li>抽象一个调用方需要的 interface , 行为包含所有使用到第三方服务的行为, 隐含的是 compsite 模式</li><li>创建 adapter 类</li><li>adapter 类加一个字段来保存第三方服务的实例</li><li>adapter 类 实现 interface 所有方法, 并在实现过程中,调用第三方服务, 对其兼容</li><li>调用方使用 adapter 实例, 在需要调用第三方的地方</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Adapter-wrapper&quot;&gt;&lt;a href=&quot;#Adapter-wrapper&quot; class=&quot;headerlink&quot; title=&quot;Adapter (wrapper)&quot;&gt;&lt;/a&gt;Adapter (wrapper)&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="Structural" scheme="https://dreambo8563.github.io/categories/Structural/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Adapter" scheme="https://dreambo8563.github.io/tags/Adapter/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Singleton</title>
    <link href="https://dreambo8563.github.io/2021/10/15/Design-Patterns-Singleton/"/>
    <id>https://dreambo8563.github.io/2021/10/15/Design-Patterns-Singleton/</id>
    <published>2021-10-15T02:53:34.000Z</published>
    <updated>2021-10-20T07:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/singleton.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>需要全局同享对象,并加以控制</li><li>保证特定类只有一个实例</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>有一个私有字段来保存 单例实例</li><li>声明一个对外的方法获取实例</li><li>获取方法,需要 lazy, 并注意多线程的时候的加锁处理</li><li>隐藏构造函数或者其他创建行方法</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Singleton&quot;&gt;&lt;a href=&quot;#Singleton&quot; class=&quot;headerlink&quot; title=&quot;Singleton&quot;&gt;&lt;/a&gt;Singleton&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.co
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Singleton" scheme="https://dreambo8563.github.io/tags/Singleton/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Builder</title>
    <link href="https://dreambo8563.github.io/2021/10/14/Design-Patterns-Builder/"/>
    <id>https://dreambo8563.github.io/2021/10/14/Design-Patterns-Builder/</id>
    <published>2021-10-14T09:37:49.000Z</published>
    <updated>2021-10-14T09:47:03.223Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Builder-Director"><a href="#Builder-Director" class="headerlink" title="Builder/Director"></a>Builder/Director</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/builder.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当你需要<strong>构建一个比较复杂的对象</strong></li><li>这个对象的各种参数,在不同情况下都不相同, 并且都是可选参数</li><li>当有一套步骤是相同,但是具体实现不同的时候, 可以引入 director</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>定义 builder interface, 具体包含能配置的东西</li><li>创建 builder 实现类, 并且需要实现一个额外的 获取结果的方法, 因为不同 builder 实现类可以输出不同类型的结果, 所以不能定义在 interface 上</li><li>创建 director 类, 封装不同的 创建步骤套装</li><li>调用方 实例化 builder 和 director. 把 builder 实例传给 director. director 选择构造那种产物. 从 build 实例获取最终结果对象</li><li>如果大家创建产物的类型一致, 则可以直接在 director 里返回结果</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Builder-Director&quot;&gt;&lt;a href=&quot;#Builder-Director&quot; class=&quot;headerlink&quot; title=&quot;Builder/Director&quot;&gt;&lt;/a&gt;Builder/Director&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Builder" scheme="https://dreambo8563.github.io/tags/Builder/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Abstract-Factory</title>
    <link href="https://dreambo8563.github.io/2021/09/27/Design-Patterns-Abstract-Factory/"/>
    <id>https://dreambo8563.github.io/2021/09/27/Design-Patterns-Abstract-Factory/</id>
    <published>2021-09-27T14:20:05.000Z</published>
    <updated>2021-09-27T14:35:20.704Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Abstract-Factory"><a href="#Abstract-Factory" class="headerlink" title="Abstract  Factory"></a>Abstract  Factory</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/Abstract%20Factory.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>当你需要<strong>包含多种模型的变种组</strong>, 而且这些模型见是有关联性的, 所以产生的组</li><li>你不希望知道具体的模型是哪种类型, 只要用就是对应的那一组</li><li>当你有多个工厂方法在某个实体里的时候,考虑抽象工厂</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>将多个模型的 interface 抽象出来, 并实现对应的变种</li><li>抽象出 factory 的 interface, 包含不同模型的创建方法</li><li>对 factory interface 进行多组的实现, 产生 factory 接口的实现类, 实现类工厂中对应产生不同的变种</li><li>客户端代码 实例化 具体的工厂类, 并用哪个工厂类产生这一组的变种模型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Abstract-Factory&quot;&gt;&lt;a href=&quot;#Abstract-Factory&quot; class=&quot;headerlink&quot; title=&quot;Abstract  Factory&quot;&gt;&lt;/a&gt;Abstract  Factory&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;ht
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Factory" scheme="https://dreambo8563.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>Design-Patterns-Factory-Method</title>
    <link href="https://dreambo8563.github.io/2021/09/14/Design-Patterns-Factory-Method/"/>
    <id>https://dreambo8563.github.io/2021/09/14/Design-Patterns-Factory-Method/</id>
    <published>2021-09-14T07:34:38.000Z</published>
    <updated>2021-09-14T07:59:18.520Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Factory-Mehtod"><a href="#Factory-Mehtod" class="headerlink" title="Factory Mehtod"></a>Factory Mehtod</h1><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/design-factory-method.png" alt=""></p><h2 id="应用场景解释"><a href="#应用场景解释" class="headerlink" title="应用场景解释"></a>应用场景解释</h2><ul><li>根据不同情况, 需要让后续逻辑使用到某个 Interface 下的不同变种(子类)</li><li>当前应用类, 对具体是哪个变种没有兴趣, 只要满足 Interface 即可</li><li>有少量的这种变种类,多的话可以演化为抽象工程模式</li></ul><h2 id="应用步骤重点"><a href="#应用步骤重点" class="headerlink" title="应用步骤重点"></a>应用步骤重点</h2><ul><li>将应用类中获取变种实例的地方变为抽象方法, 应用类本身变为抽象类<blockquote><p>+createBtn() IBtn</p></blockquote></li><li>生成对应的 应用实现类, 实现createBtn, 返回对应的变种实例</li><li>在使用应用类实例的地方, 根据实际参数, 选择实例化具体的 某个应用实现类</li></ul><blockquote><p>简单使用的时候, 偷懒对应用类不做变化, 单纯当返回不同变种实例的逻辑封装在 createBtn(). 降低一些复杂度, 减少继承关系</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Factory-Mehtod&quot;&gt;&lt;a href=&quot;#Factory-Mehtod&quot; class=&quot;headerlink&quot; title=&quot;Factory Mehtod&quot;&gt;&lt;/a&gt;Factory Mehtod&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://raw.
      
    
    </summary>
    
      <category term="Creational" scheme="https://dreambo8563.github.io/categories/Creational/"/>
    
    
      <category term="Design" scheme="https://dreambo8563.github.io/tags/Design/"/>
    
      <category term="Factory" scheme="https://dreambo8563.github.io/tags/Factory/"/>
    
  </entry>
  
  <entry>
    <title>sentry-trace</title>
    <link href="https://dreambo8563.github.io/2021/06/18/sentry-trace/"/>
    <id>https://dreambo8563.github.io/2021/06/18/sentry-trace/</id>
    <published>2021-06-17T16:48:43.000Z</published>
    <updated>2021-06-17T17:14:54.134Z</updated>
    
    <content type="html"><![CDATA[<h3 id="链路跟踪"><a href="#链路跟踪" class="headerlink" title="链路跟踪"></a>链路跟踪</h3><p>之前研究用jaeger 对程序进行侵入式的链路跟踪. 包括 http. grpc 协议的情况</p><h4 id="sentry"><a href="#sentry" class="headerlink" title="sentry"></a>sentry</h4><p>最近我们新搭建了新版本的sentry, 发现了之前没有的 feature -&gt; <strong>Performance</strong><br>从前端 Vue 到 PHP 的 Lavaral 到 内部的 GO 服务, 尝试了一下链路. 效果基本满足我们的需求.</p><h4 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h4><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/tracing1.png" alt=""></p><p>这里只是一个例子, 对 Vue 和 Lavaral 的支持比较好, 整合的时候基本没有入侵代码. 能够自动进行跟踪. 包括:</p><ul><li>前端静态资源</li><li>http 请求自动分拆</li><li>后端能够跟踪到具体 sql (Lavaral)</li></ul><p>缺点也有一些:</p><ul><li>SDK 不够完善. 后端继续向内部服务链路的时候可能需要改造中间件, 没有自动传送sentry-trace 头</li><li>接受上游的 trace 的时候可能需要看看源码, 文档不是很完善</li><li>很多语言框架无法自动采集链路, 需要自己在业务里写强侵入式的代码</li></ul><p>采集上来的数据能够阶段性比较:</p><blockquote><p>优化前性能指标</p></blockquote><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/tracing2.png" alt=""></p><blockquote><p>优化后</p></blockquote><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/tracing3.png" alt=""></p><p>这样能够很明显的看出近期的改动是否有作用.<br>同时能够协助发现能够优化的地方</p><ul><li>比如接口过多</li><li>静态资源过多, 或者过早引入</li><li>接口没有并行触发</li><li>慢 sql 等</li></ul><h4 id="给-Sentry-点赞"><a href="#给-Sentry-点赞" class="headerlink" title="给 Sentry 点赞"></a>给 Sentry 点赞</h4><ul><li>保持了错误捕获相关的能力</li><li>增强了 Tracing 和 Logging 的能力<br>对一般的可观测性都能满足需求了, 而且覆盖了前后端, 不同语言和框架. 反正大不了就是自己看源码, 或者自己实现点逻辑, 已经很不错了</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;链路跟踪&quot;&gt;&lt;a href=&quot;#链路跟踪&quot; class=&quot;headerlink&quot; title=&quot;链路跟踪&quot;&gt;&lt;/a&gt;链路跟踪&lt;/h3&gt;&lt;p&gt;之前研究用jaeger 对程序进行侵入式的链路跟踪. 包括 http. grpc 协议的情况&lt;/p&gt;
&lt;h4 id=&quot;sen
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="Sentry" scheme="https://dreambo8563.github.io/tags/Sentry/"/>
    
      <category term="Tracing" scheme="https://dreambo8563.github.io/tags/Tracing/"/>
    
  </entry>
  
  <entry>
    <title>最近两年的架构演进</title>
    <link href="https://dreambo8563.github.io/2021/05/30/%E6%9C%80%E8%BF%91%E4%B8%A4%E5%B9%B4%E7%9A%84%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
    <id>https://dreambo8563.github.io/2021/05/30/最近两年的架构演进/</id>
    <published>2021-05-30T15:38:53.000Z</published>
    <updated>2021-05-30T15:47:13.873Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间"><a href="#最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间" class="headerlink" title="最近两年由于前后端都负责, 就给与了很大的架构锻炼的机会和空间"></a>最近两年由于前后端都负责, 就给与了很大的架构锻炼的机会和空间</h3><h5 id="Stage1"><a href="#Stage1" class="headerlink" title="Stage1"></a>Stage1</h5><ul><li>原始阶段</li><li>实体机直接部署</li><li>手动发布打包</li></ul><h5 id="Stage2"><a href="#Stage2" class="headerlink" title="Stage2"></a>Stage2</h5><ul><li>前端jenkins</li><li>前端全量部署 CDN/OSS</li><li>全栈 https</li></ul><h5 id="Stage3"><a href="#Stage3" class="headerlink" title="Stage3"></a>Stage3</h5><ul><li>后端容器化部署</li><li>后端 CD 自动化</li><li>增加伸缩性和自我恢复能力</li></ul><h5 id="Stage4"><a href="#Stage4" class="headerlink" title="Stage4"></a>Stage4</h5><ul><li>前端部署容器化</li><li>后端服务拆分,实践 DDD</li><li>客户端机制隐藏后端服务实现,版本化升级</li><li>引入 ES 的使用</li><li>部分Go 服务实践</li><li>区分业务数据和通用静态数据</li><li>引入 Graphql, 提高开发效率</li><li>接入 kafka</li></ul><h4 id="全景路线图"><a href="#全景路线图" class="headerlink" title="全景路线图"></a>全景路线图</h4><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/Evolution.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间&quot;&gt;&lt;a href=&quot;#最近两年由于前后端都负责-就给与了很大的架构锻炼的机会和空间&quot; class=&quot;headerlink&quot; title=&quot;最近两年由于前后端都负责, 就给与了很大的架构锻炼的机会和空间&quot;
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>DDD实践项目1</title>
    <link href="https://dreambo8563.github.io/2021/05/23/DDD%E5%AE%9E%E8%B7%B5%E9%A1%B9%E7%9B%AE1/"/>
    <id>https://dreambo8563.github.io/2021/05/23/DDD实践项目1/</id>
    <published>2021-05-23T15:34:14.000Z</published>
    <updated>2021-05-23T15:43:52.374Z</updated>
    
    <content type="html"><![CDATA[<h3 id="之前读了一些DDD相关的数据-也在一个项目上实践了一下"><a href="#之前读了一些DDD相关的数据-也在一个项目上实践了一下" class="headerlink" title="之前读了一些DDD相关的数据, 也在一个项目上实践了一下"></a>之前读了一些DDD相关的数据, 也在一个项目上实践了一下</h3><h4 id="理由"><a href="#理由" class="headerlink" title="理由"></a>理由</h4><ul><li>后台项目大部分不具有技术上的挑战</li><li>基于 k8s, 云等技术的普及. 横向扩展伸缩, 稳定性等基础架构变得普及和容易解决</li><li>难点聚焦于业务复杂度, 业务架构的设计上</li></ul><h4 id="demo1"><a href="#demo1" class="headerlink" title="demo1"></a>demo1</h4><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/ddd1.png" alt=""></p><ul><li>内层是核心业务模型(粉色+绿色)</li><li>领域服务/独立模块(黄色)</li><li>外层是基础设施(可替换)<blockquote><p>外部服务 可以 用 DI 方式 注入到 核心逻辑中(做个抽象 - 门面模式), 核心业务逻辑无需关心服务的具体实现</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/ddd1-1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;之前读了一些DDD相关的数据-也在一个项目上实践了一下&quot;&gt;&lt;a href=&quot;#之前读了一些DDD相关的数据-也在一个项目上实践了一下&quot; class=&quot;headerlink&quot; title=&quot;之前读了一些DDD相关的数据, 也在一个项目上实践了一下&quot;&gt;&lt;/a&gt;之前读了
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="DDD" scheme="https://dreambo8563.github.io/tags/DDD/"/>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/tags/Architecture/"/>
    
  </entry>
  
  <entry>
    <title>FE-CDN</title>
    <link href="https://dreambo8563.github.io/2021/05/21/FE-CDN/"/>
    <id>https://dreambo8563.github.io/2021/05/21/FE-CDN/</id>
    <published>2021-05-21T08:59:37.000Z</published>
    <updated>2021-05-21T10:20:36.562Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣"><a href="#最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣" class="headerlink" title="最近把项目的前端部署策略优化了下,顺手对比了几种方式的优劣"></a>最近把项目的前端部署策略优化了下,顺手对比了几种方式的优劣</h1><h3 id="策略-1"><a href="#策略-1" class="headerlink" title="策略 1"></a>策略 1</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/cdn1.png" alt=""></p><ul><li>打包产物全量推送 OSS</li><li>CDN 域名回源 OSS (阿里业务)</li><li>前端跨域访问后端 api 服务</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>依托阿里云</li><li>不需要前端用的 web 服务</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>CDN 缓存问题需要处理</li><li>需要通过 CDN 上正则模拟 history 模式, 返回 index.html</li><li>跨域 Option 请求</li></ul><hr><hr><h3 id="策略-2"><a href="#策略-2" class="headerlink" title="策略 2"></a>策略 2</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/cdn2.png" alt=""></p><ul><li>打包产物(非 index.htm)推送 OSS</li><li>公用CDN 域名回源 OSS (阿里业务)</li><li>用户访问自己的 nginx 服务(index.html)</li><li>index.html 上利用 script 标签调用 cdn 上的 js/css等静态资源</li><li>nginx 反向代理访问 api</li></ul><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ul><li>绝大部分静态利用 CDN 资源</li><li>自己控制缓存,增强可编程能力</li><li>不跨域</li></ul><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ul><li>打包配置需要独立处理</li><li>需要自己的 web 服务</li></ul><hr><hr><h3 id="策略-3"><a href="#策略-3" class="headerlink" title="策略 3"></a>策略 3</h3><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/cdn3.png" alt=""></p><ul><li>打包产物放自己 nginx</li><li>公用CDN域名回源自己的 web服务</li><li>用户访问CDN</li><li>nginx 反向代理访问 api</li></ul><h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><ul><li>利用 CDN 能力</li><li>自己控制缓存,增强可编程能力</li><li>不跨域</li></ul><h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><ul><li>CDN 缓存问题</li><li>回源还是会占用自己的流量带宽</li><li>需要自己的 web 服务</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣&quot;&gt;&lt;a href=&quot;#最近把项目的前端部署策略优化了下-顺手对比了几种方式的优劣&quot; class=&quot;headerlink&quot; title=&quot;最近把项目的前端部署策略优化了下,顺手对比了几种方式的优劣&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="FE" scheme="https://dreambo8563.github.io/categories/FE/"/>
    
    
      <category term="CDN" scheme="https://dreambo8563.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>JS波浪符巧用</title>
    <link href="https://dreambo8563.github.io/2020/07/03/JS%E6%B3%A2%E6%B5%AA%E7%AC%A6%E5%B7%A7%E7%94%A8/"/>
    <id>https://dreambo8563.github.io/2020/07/03/JS波浪符巧用/</id>
    <published>2020-07-03T15:00:37.000Z</published>
    <updated>2020-07-03T15:08:15.198Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>原文地址: <a href="https://khalilstemmler.com/articles/tilde-in-javascript/" target="_blank" rel="noopener">https://khalilstemmler.com/articles/tilde-in-javascript/</a></p><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>源于一段代码</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(~followers.indexOf(target)) &#123;</span><br><span class="line">  <span class="comment">// do some action</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="深挖"><a href="#深挖" class="headerlink" title="深挖"></a>深挖</h2><p>~A 同等于 -(A + 1)</p><h2 id="和-JS-的联系"><a href="#和-JS-的联系" class="headerlink" title="和 JS 的联系"></a>和 JS 的联系</h2><blockquote><p>The indexOf() method returns the first index at which a given element can be found in the array, or -1 if it is not present.</p></blockquote><blockquote><p>The indexOf() method returns the index within the calling String object of the first occurrence of the specified value, starting the search at fromIndex. Returns -1 if the value is not found.</p></blockquote><p>只有当 A=-1 的时候 ~A === 0 </p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>不用去和 -1 比了!!!<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!!~fruits.indexOf(<span class="string">'apples'</span>)) &#123;</span><br><span class="line">  <span class="comment">// Yay apples</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Found apples!"</span>) <span class="comment">// &lt;= this will print</span></span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Still no apples</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"No apples apparently"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引用&quot;&gt;&lt;a href=&quot;#引用&quot; class=&quot;headerlink&quot; title=&quot;引用&quot;&gt;&lt;/a&gt;引用&lt;/h2&gt;&lt;p&gt;原文地址: &lt;a href=&quot;https://khalilstemmler.com/articles/tilde-in-javascript
      
    
    </summary>
    
      <category term="JS" scheme="https://dreambo8563.github.io/categories/JS/"/>
    
    
      <category term="JS" scheme="https://dreambo8563.github.io/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>Vue-Mixin-Table</title>
    <link href="https://dreambo8563.github.io/2020/04/28/Vue-Mixin-Table/"/>
    <id>https://dreambo8563.github.io/2020/04/28/Vue-Mixin-Table/</id>
    <published>2020-04-28T12:48:07.000Z</published>
    <updated>2020-04-28T14:13:30.738Z</updated>
    
    <content type="html"><![CDATA[<p>今天想分享一个日常后台管理系统中常用的一个工具.</p><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>我们写后台管理系统, 有非常多的列表页,一般都带分页操作, 这其实就会出现大量模板代码,重复代码 -&gt; 体力劳动.</p><h2 id="Mixin"><a href="#Mixin" class="headerlink" title="Mixin"></a>Mixin</h2><p>mixin 是 Vue 里面的一个特性, 我们一般会把通用的操作放在这里, 但一般会放和组件内容没有紧密关联的动作.</p><h2 id="梳理抽离前的情况"><a href="#梳理抽离前的情况" class="headerlink" title="梳理抽离前的情况"></a>梳理抽离前的情况</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">data()&#123;</span><br><span class="line">    <span class="keyword">return</span>&#123;</span><br><span class="line">        xxx 分页相关参数,</span><br><span class="line">        其他业务参数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods:&#123;</span><br><span class="line"> 获取列表方法...</span><br><span class="line"> 改变页数方法...</span><br><span class="line"> 改变单页个数方法...</span><br><span class="line"> 改变过滤条件方法...</span><br><span class="line"> xxx 其他交互方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/dreambo8563/static-assets/master/MixinTable.png" alt=""></p><h2 id="分解动态部分"><a href="#分解动态部分" class="headerlink" title="分解动态部分"></a>分解动态部分</h2><ol><li>请求参数是可变的, 数量不定</li><li>请求的 API,是不同的</li><li>请求结果处理方式不完全一样</li></ol><blockquote><p>所有的动态部分都需要使用 mixin 的组件给与之对应的配合, 这似乎是违背的 mixin 的使用初衷, 让 mixin降低了独立性; 但从另一个方面想, mixin 就像 interface. 对于不同的场景增加不同的能力, 似乎也说的通. </p></blockquote><h2 id="上代码"><a href="#上代码" class="headerlink" title="上代码"></a>上代码</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PAGINATION_SIZE_ENUM &#125; <span class="keyword">from</span> <span class="string">"@/constants/TEXT"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  data() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      pageSize: <span class="number">20</span>,</span><br><span class="line">      currentPage: <span class="number">1</span>,</span><br><span class="line">      total: <span class="number">0</span>,</span><br><span class="line">      tableData: [],</span><br><span class="line">      constants: &#123;</span><br><span class="line">        PAGINATION_SIZE_ENUM</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleCurrentChange(val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.getTableList(&#123; ...this.getBaseParams(), <span class="attr">page</span>: val &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    handleSizeChange(val) &#123;</span><br><span class="line">      <span class="keyword">this</span>.pageSize = val;</span><br><span class="line">      <span class="keyword">this</span>.currentPage = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">this</span>.getTableList(&#123; ...this.getBaseParams(), <span class="attr">per_page</span>: val, <span class="attr">page</span>: <span class="number">1</span> &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    getTableList(args = <span class="keyword">this</span>.getBaseParams(), callback?: <span class="built_in">Function</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.startLoading();</span><br><span class="line">      <span class="keyword">const</span> params = <span class="built_in">Array</span>.isArray(args) ? args : [args];</span><br><span class="line">      <span class="keyword">this</span>.tableListAPI(...params).then(<span class="function">(<span class="params">res: any</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.stopLoading();</span><br><span class="line">        <span class="keyword">if</span> (callback) &#123;</span><br><span class="line">          <span class="keyword">return</span> callback(res);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> &#123; data, total &#125; = res;</span><br><span class="line">        <span class="keyword">this</span>.tableData = data;</span><br><span class="line">        <span class="keyword">this</span>.total = total;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.tableListAPI)</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"please provide `tableListAPI` for formMixin"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.getBaseParams)</span><br><span class="line">      <span class="built_in">console</span>.error(</span><br><span class="line">        <span class="string">"please provide `getBaseParams` function for formMixin to get params for request"</span></span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>data 是 mixin 本身应用到的数据,相对是固定的<br><code>handleCurrentChange</code>/<code>handleSizeChange</code> 是处理分页相关操作<br><code>getTableList</code> 是获取列表数据操作</p></blockquote><p><strong>需要配合:</strong><br><code>tableListAPI</code>, 赋值请求的 api<br><code>getBaseParams</code> 需要返回基本的列表参数<br><code>getTableList</code> 接受请求参数-当有多个的时候需要以 Array 类型传入, 接受 callback 作为可选第二参数,来处理返回结果</p><p><code>created</code> 里面的验证是为了让使用者知道这个 mixin 和组件间是有耦合的, 需要组件配合才能使用</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>懒,真的特别懒</li><li>尽量大家能统一</li><li>提高效率</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天想分享一个日常后台管理系统中常用的一个工具.&lt;/p&gt;
&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;我们写后台管理系统, 有非常多的列表页,一般都带分页操作, 这其实就会出现大
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
      <category term="mixin" scheme="https://dreambo8563.github.io/tags/mixin/"/>
    
  </entry>
  
  <entry>
    <title>2019总结</title>
    <link href="https://dreambo8563.github.io/2020/01/21/2019%E6%80%BB%E7%BB%93/"/>
    <id>https://dreambo8563.github.io/2020/01/21/2019总结/</id>
    <published>2020-01-21T02:18:57.000Z</published>
    <updated>2020-01-21T02:53:24.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2019-有点特别的一年"><a href="#2019-有点特别的一年" class="headerlink" title="2019 有点特别的一年"></a>2019 有点特别的一年</h2><h3 id="前端技术"><a href="#前端技术" class="headerlink" title="前端技术"></a>前端技术</h3><p>更熟悉的使用 vue, 团队已普遍接入 sentry, https/pwa. 部分使用 CDN. jenkins. 更多关注 sonar 这种静态检查. 技术推动还算有些成效.<br>封装了几个 lib 已经 publish 到 npm. 并在项目的使用. 技术面输入降低.</p><h3 id="flutter"><a href="#flutter" class="headerlink" title="flutter"></a>flutter</h3><p>开始初步接触 flutter, 小 demo 走起, 值得长期玩.<br><a href="https://github.com/dreambo8563/flutter-aesop-demo" target="_blank" rel="noopener">https://github.com/dreambo8563/flutter-aesop-demo</a></p><h3 id="角色转型"><a href="#角色转型" class="headerlink" title="角色转型"></a>角色转型</h3><p>半数精力转向产品,运营, 团队管理, 进度管理<br>负责所在项目的整体技术, 参与内部外部沟通, 需求细节敲定, 排期, 技术资源安排, 绩效评定.<br>帮助某个项目画了粗糙的原型. 突如其来的转型, 让原本的 2019 计划发生很大变化. 增加业务输出, 减少了技术输入. 这恐怕是转型的必经之路. 但同时作为项目的前端部分的主要战斗力还是足够的.</p><h3 id="More"><a href="#More" class="headerlink" title="More"></a>More</h3><p>需要一些技术输入, 产品运营方向不能减少, 团队管理技能需要加强. 多学习</p><ul><li>Blog -&gt; 12 篇</li><li>github提交 -&gt; 1,024</li><li>仓库star:<ul><li><a href="https://github.com/dreambo8563/vue-particle-effect-buttons" target="_blank" rel="noopener">vue-particle-effect-buttons</a> -&gt; 162</li><li><a href="https://github.com/dreambo8563/vue-piece-slider" target="_blank" rel="noopener">vue-piece-slider</a> -&gt; 71</li><li><a href="https://github.com/dreambo8563/easy-circular-progress" target="_blank" rel="noopener">easy-circular-progress</a> -&gt; 65</li><li><a href="https://github.com/dreambo8563/vue-storage-watcher" target="_blank" rel="noopener">vue-storage-watcher</a> -&gt; 37</li><li><a href="https://github.com/dreambo8563/vue-device-detector" target="_blank" rel="noopener">vue-device-detector</a> -&gt; 29</li><li><a href="https://github.com/dreambo8563/vue-simple-drawer" target="_blank" rel="noopener">vue-simple-drawer</a> -&gt; 26</li></ul></li><li>读书大多是关于产品运营相关的, 技术书籍较少.</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2019-有点特别的一年&quot;&gt;&lt;a href=&quot;#2019-有点特别的一年&quot; class=&quot;headerlink&quot; title=&quot;2019 有点特别的一年&quot;&gt;&lt;/a&gt;2019 有点特别的一年&lt;/h2&gt;&lt;h3 id=&quot;前端技术&quot;&gt;&lt;a href=&quot;#前端技术&quot; cla
      
    
    </summary>
    
      <category term="Thinking" scheme="https://dreambo8563.github.io/categories/Thinking/"/>
    
    
      <category term="Thinking" scheme="https://dreambo8563.github.io/tags/Thinking/"/>
    
  </entry>
  
  <entry>
    <title>CDN回源OSS - 阿里云</title>
    <link href="https://dreambo8563.github.io/2019/07/03/CDN%E5%9B%9E%E6%BA%90OSS-%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    <id>https://dreambo8563.github.io/2019/07/03/CDN回源OSS-阿里云/</id>
    <published>2019-07-03T00:17:14.000Z</published>
    <updated>2019-07-03T00:31:33.670Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前端-CDN-实践"><a href="#前端-CDN-实践" class="headerlink" title="前端 CDN 实践"></a>前端 CDN 实践</h2><p>回源 OSS 的益处:</p><ul><li>节省自己的带宽</li><li>前端独立部署</li><li>自动刷新 CDN</li><li>相应的省钱,不用物理机部署</li></ul><p>CDN:</p><ul><li>全国节点</li><li>缓存能力</li><li>自带访问限制等手段</li></ul><h3 id="步骤-一下以-vue-SPA-为例"><a href="#步骤-一下以-vue-SPA-为例" class="headerlink" title="步骤 - 一下以 vue SPA 为例"></a>步骤 - 一下以 vue SPA 为例</h3><ol><li>创建 OSS 选私有, 最好开通日志</li><li>配置 OSS 为静态站点模式, 这只默认首页和 404 页面都为 index.html</li><li>CDN 设置 - 添加域名, 设置加速的域名, 我们一般就选择 <strong>图片小文件</strong>, 类型为 OSS 端口 80</li><li>回源配置 - 授权私有 Bucket</li><li>缓存配置重点配置 <strong>重写</strong>部分<ul><li>^/\$ 目标为/index.html break 模式 - 访问跟域名的时候输出 index.html 否则会报 403</li><li>^/(?!.<em><a href="pdf|zip|xls|doc|mid|bmp|gif|wav|mp3|wma|avi|mov|swf|webp|tif|js|css|jpg|jpeg|ico|json|woff|woff2|eot|ttf|svg|png|txt|docx|xlsx|wmv|rmavb|mpeg|mp4|csv|apk">.</a>\$).</em>\$ 目标为 /index.hmtl break 模式 - 把非静态资源当做前端路由, 输出 index.html 内容</li></ul></li><li>配置 https 上传相关证书信息, 开启 http2 和强制跳转, 开启所有 TLS 版本支持</li><li>访问控制, 添加 Refer 白名单</li><li>性能优化, 开启 Brotli 压缩</li></ol><h3 id="Vue-项目修改"><a href="#Vue-项目修改" class="headerlink" title="Vue 项目修改"></a>Vue 项目修改</h3><p>当需要上传 CDN 的时候, 需要修改 publicPath 的位置如: “//xxxx.yy.com/“</p><h3 id="利用阿里云的上传命令行上传即可"><a href="#利用阿里云的上传命令行上传即可" class="headerlink" title="利用阿里云的上传命令行上传即可"></a>利用阿里云的上传命令行上传即可</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前端-CDN-实践&quot;&gt;&lt;a href=&quot;#前端-CDN-实践&quot; class=&quot;headerlink&quot; title=&quot;前端 CDN 实践&quot;&gt;&lt;/a&gt;前端 CDN 实践&lt;/h2&gt;&lt;p&gt;回源 OSS 的益处:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节省自己的带宽&lt;/li&gt;
&lt;li&gt;
      
    
    </summary>
    
      <category term="Architecture" scheme="https://dreambo8563.github.io/categories/Architecture/"/>
    
    
      <category term="CDN" scheme="https://dreambo8563.github.io/tags/CDN/"/>
    
  </entry>
  
  <entry>
    <title>Vue 搭配 Typescript 体验总结</title>
    <link href="https://dreambo8563.github.io/2019/06/16/Vue-%E6%90%AD%E9%85%8D-Typescript-%E4%BD%93%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://dreambo8563.github.io/2019/06/16/Vue-搭配-Typescript-体验总结/</id>
    <published>2019-06-16T13:33:22.000Z</published>
    <updated>2019-06-16T13:34:47.307Z</updated>
    
    <content type="html"><![CDATA[<p align="center"><br>    <a href="https://www.iviewui.com" target="_blank" rel="noopener"><br>        <img width="200" src="https://user-gold-cdn.xitu.io/2019/6/5/16b25edae09075a2?w=128&h=128&f=svg&s=1837"><br>    </a><br></p><p>工作中我们使用的部分 typescript + Vue + Element-ui.</p><p>最近想尝试下用 Class 的风格写组件, 更多的引入类型来约束开发, 提高体验. 所以本周开了一个仓库.</p><ol><li><p>选定目标为 iview-admin (iview 之前没用过,所以顺便搞下)</p></li><li><p>引入 vue-class-component/vue-property-decorator/vuex-class</p></li><li><p>逐个组件/页面转为 typescript 和 class 风格</p></li></ol><p>地址:</p><p><a href="https://github.com/dreambo8563/typescript-iview-admin" target="_blank" rel="noopener">https://github.com/dreambo8563/typescript-iview-admin</a></p><p><img src="https://user-gold-cdn.xitu.io/2019/6/5/16b25e98eacdd571?w=2850&amp;h=1414&amp;f=png&amp;s=338122" alt="image"></p><p>总结:</p><p>体验还不太行. 类型提示甚至会错误显示(不知道是不是 vscode 的问题 )</p><p>jsx 的使用没有找到办法, 部分代码我只能转换为 render 函数来搞</p><p>有些第三方没有 typings, 不得不用 any.</p><p>当然在 ts 的加持下,发现了原仓库代码的一些问题, 比如很多 undefined 的情况没有判断处理, 还有未使用的函数.<br>使用未声明的变量等等</p><p>所以这次花了几天时间做这个实践还是有意义的. 3.0 稳定之前<strong>不宜</strong>全面使用 Class 风格来搞组件.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p align=&quot;center&quot;&gt;&lt;br&gt;    &lt;a href=&quot;https://www.iviewui.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;&lt;br&gt;        &lt;img width=&quot;200&quot; src=&quot;https://user-go
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue - Load chunk xxxx failed</title>
    <link href="https://dreambo8563.github.io/2019/05/23/Vue-Load-chunk-xxxx-failed/"/>
    <id>https://dreambo8563.github.io/2019/05/23/Vue-Load-chunk-xxxx-failed/</id>
    <published>2019-05-23T07:26:29.000Z</published>
    <updated>2019-05-23T07:34:22.437Z</updated>
    
    <content type="html"><![CDATA[<h3 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h3><p>code split 是 SPA 中常用的优化方式, 一般基于路由分割. 每个路由会拆分为不同的独立 js.</p><p>但不管是 react /vue 有时都会遇到切换路由的时候发生 <em>Load chunk xxxx failed</em> 的错误. 几率不大, 但是目前我还未找到一个大家公认的原因.</p><p>所有我们需要 catch 这个错误.</p><h3 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">router.onError(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> pattern = <span class="regexp">/Loading chunk ([a-z]|[0-9]|-)+ failed/g</span>;</span><br><span class="line">  <span class="keyword">const</span> isChunkLoadFailed = error.message.match(pattern);</span><br><span class="line">  <span class="comment">// const targetPath = router.fullPath;</span></span><br><span class="line">  <span class="keyword">if</span> (isChunkLoadFailed) &#123;</span><br><span class="line">    Vue.prototype.$alert(<span class="string">'网页资源加载失败,请刷新页面'</span>, <span class="string">'提示'</span>, &#123;</span><br><span class="line">      confirmButtonText: <span class="string">'确定'</span>,</span><br><span class="line">      callback: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        location.replace(location.href);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>catch 到给用户一个提示, 让他刷新页面</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;错误描述&quot;&gt;&lt;a href=&quot;#错误描述&quot; class=&quot;headerlink&quot; title=&quot;错误描述&quot;&gt;&lt;/a&gt;错误描述&lt;/h3&gt;&lt;p&gt;code split 是 SPA 中常用的优化方式, 一般基于路由分割. 每个路由会拆分为不同的独立 js.&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
      <category term="vue" scheme="https://dreambo8563.github.io/categories/vue/"/>
    
    
      <category term="vue" scheme="https://dreambo8563.github.io/tags/vue/"/>
    
  </entry>
  
</feed>
